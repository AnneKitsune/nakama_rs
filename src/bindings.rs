/* automatically generated by rust-bindgen 0.56.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 32;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const NDEFAULT_PORT: i32 = -1;
pub const __GNUC_VA_LIST: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = "< The user is a superadmin with full control of the group."]
pub const NUserGroupState_NUserGroupState_SUPERADMIN: NUserGroupState = 0;
#[doc = "< The user is an admin with additional privileges."]
pub const NUserGroupState_NUserGroupState_ADMIN: NUserGroupState = 1;
#[doc = "< The user is a regular member."]
pub const NUserGroupState_NUserGroupState_MEMBER: NUserGroupState = 2;
#[doc = "< The user has requested to join the group"]
pub const NUserGroupState_NUserGroupState_JOIN_REQUEST: NUserGroupState = 3;
#[doc = " The group role status."]
pub type NUserGroupState = ::std::os::raw::c_uint;
#[doc = " The group role status."]
pub use self::NUserGroupState as eNUserGroupState;
#[doc = "< Default case. Assumed as ROOM type."]
pub const NChannelType_NChannelType_TYPE_UNSPECIFIED: NChannelType = 0;
#[doc = "< A chat room which can be created dynamically with a name."]
pub const NChannelType_NChannelType_ROOM: NChannelType = 1;
#[doc = "< A private chat between two users."]
pub const NChannelType_NChannelType_DIRECT_MESSAGE: NChannelType = 2;
#[doc = "< A chat within a group on the server."]
pub const NChannelType_NChannelType_GROUP: NChannelType = 3;
#[doc = " The available channel types on the server."]
pub type NChannelType = ::std::os::raw::c_uint;
#[doc = " The available channel types on the server."]
pub use self::NChannelType as eNChannelType;
#[doc = " UNIX time in milliseconds."]
#[doc = " Use getUnixTimestampMs() to get current time."]
pub type NTimestamp = u64;
pub type bool_ = u8;
#[doc = " array of bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NBytes {
    pub bytes: *mut u8,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_NBytes() {
    assert_eq!(
        ::std::mem::size_of::<NBytes>(),
        16usize,
        concat!("Size of: ", stringify!(NBytes))
    );
    assert_eq!(
        ::std::mem::align_of::<NBytes>(),
        8usize,
        concat!("Alignment of ", stringify!(NBytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NBytes>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NBytes),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NBytes>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NBytes),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " array of bytes"]
pub type sNBytes = NBytes;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStringMap_ {
    pub c: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStringMap_() {
    assert_eq!(
        ::std::mem::size_of::<NStringMap_>(),
        1usize,
        concat!("Size of: ", stringify!(NStringMap_))
    );
    assert_eq!(
        ::std::mem::align_of::<NStringMap_>(),
        1usize,
        concat!("Alignment of ", stringify!(NStringMap_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStringMap_>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStringMap_),
            "::",
            stringify!(c)
        )
    );
}
pub type NStringMap = *mut NStringMap_;
extern "C" {
    #[doc = " Creates string map."]
    #[doc = ""]
    #[doc = " @return NStringMap."]
    pub fn NStringMap_create() -> NStringMap;
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param key The key. The key value will be overwritten if it already exists."]
    #[doc = " @param value The value of a key."]
    pub fn NStringMap_setValue(
        map: NStringMap,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param key The key to receive value for."]
    #[doc = " @return value of the key. NULL is key was not found."]
    pub fn NStringMap_getValue(
        map: NStringMap,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param keysArray The output keys array. Allocate first."]
    pub fn NStringMap_getKeys(map: NStringMap, keysArray: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @return size of the map."]
    pub fn NStringMap_getSize(map: NStringMap) -> u16;
}
extern "C" {
    #[doc = " Destroy a string map."]
    #[doc = ""]
    #[doc = " @param map The string map."]
    pub fn NStringMap_destroy(map: NStringMap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NSession_ {
    pub c: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NSession_() {
    assert_eq!(
        ::std::mem::size_of::<NSession_>(),
        1usize,
        concat!("Size of: ", stringify!(NSession_))
    );
    assert_eq!(
        ::std::mem::align_of::<NSession_>(),
        1usize,
        concat!("Alignment of ", stringify!(NSession_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NSession_>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NSession_),
            "::",
            stringify!(c)
        )
    );
}
pub type NSession = *mut NSession_;
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return The authentication token used to construct this session."]
    pub fn NSession_getAuthToken(session: NSession) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return <c>True</c> if the user account for this session was just created."]
    pub fn NSession_isCreated(session: NSession) -> bool_;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return The username of the user who owns this session."]
    pub fn NSession_getUsername(session: NSession) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return The ID of the user who owns this session."]
    pub fn NSession_getUserId(session: NSession) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return The timestamp in milliseconds when this session object was created."]
    pub fn NSession_getCreateTime(session: NSession) -> NTimestamp;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return The timestamp in milliseconds when this session will expire."]
    pub fn NSession_getExpireTime(session: NSession) -> NTimestamp;
}
extern "C" {
    #[doc = " @param session The session."]
    #[doc = " @return <c>True</c> if the session has expired against the current time."]
    pub fn NSession_isExpired(session: NSession) -> bool_;
}
extern "C" {
    #[doc = " Check if the session has expired against the input time."]
    #[doc = ""]
    #[doc = " @param session The session."]
    #[doc = " @param now The time to compare against the session."]
    #[doc = "        Use getUnixTimestampMs() to get current time."]
    #[doc = " @return <c>true</c> if the session has expired."]
    pub fn NSession_isExpiredByTime(session: NSession, now: NTimestamp) -> bool_;
}
extern "C" {
    #[doc = " Get session variables."]
    #[doc = ""]
    #[doc = " @param session The session."]
    #[doc = " @return NStringMap. Delete it after usage with NStringMap_destroy()"]
    pub fn NSession_getVariables(session: NSession) -> NStringMap;
}
extern "C" {
    #[doc = " Get session variable value by name."]
    #[doc = ""]
    #[doc = " @param session The session."]
    #[doc = " @return variable value or NULL if not found."]
    pub fn NSession_getVariable(
        session: NSession,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Restore a session from an authentication token."]
    #[doc = ""]
    #[doc = " @param token The authentication token from a <c>NSession</c>."]
    #[doc = " @return A session restored from the authentication token."]
    pub fn restoreNakamaSession(token: *const ::std::os::raw::c_char) -> NSession;
}
extern "C" {
    #[doc = " Destroy a session."]
    #[doc = ""]
    #[doc = " @param session The session."]
    pub fn NSession_destroy(session: NSession);
}
#[doc = " Unknown error"]
pub const NErrorCode_NErrorCode_Unknown: NErrorCode = 0;
#[doc = " Some requested entity was not found."]
pub const NErrorCode_NErrorCode_NotFound: NErrorCode = 1;
#[doc = " Some entity that we attempted to create already exists."]
pub const NErrorCode_NErrorCode_AlreadyExists: NErrorCode = 2;
#[doc = " Client specified an invalid argument."]
pub const NErrorCode_NErrorCode_InvalidArgument: NErrorCode = 3;
#[doc = " The request does not have valid authentication credentials for the operation."]
pub const NErrorCode_NErrorCode_Unauthenticated: NErrorCode = 4;
#[doc = " The caller does not have permission to execute the specified operation."]
pub const NErrorCode_NErrorCode_PermissionDenied: NErrorCode = 5;
#[doc = " The service is currently unavailable. This is a most likely a transient"]
#[doc = " condition and may be corrected by retrying with a backoff."]
#[doc = ""]
#[doc = " \\warning Although data MIGHT not have been transmitted when this"]
#[doc = " status occurs, there is NOT A GUARANTEE that the server has not seen"]
#[doc = " anything. So in general it is unsafe to retry on this status code"]
#[doc = " if the call is non-idempotent."]
pub const NErrorCode_NErrorCode_ConnectionError: NErrorCode = -1;
#[doc = " Internal errors. Means some invariants expected by underlying System has"]
#[doc = " been broken. If you see one of these errors, Something is very broken."]
pub const NErrorCode_NErrorCode_InternalError: NErrorCode = -2;
#[doc = " The request has been cancelled by user."]
pub const NErrorCode_NErrorCode_CancelledByUser: NErrorCode = -3;
#[doc = " Error codes"]
pub type NErrorCode = ::std::os::raw::c_int;
#[doc = " Error codes"]
pub use self::NErrorCode as tNErrorCode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NError {
    pub message: *const ::std::os::raw::c_char,
    pub code: tNErrorCode,
}
#[test]
fn bindgen_test_layout_NError() {
    assert_eq!(
        ::std::mem::size_of::<NError>(),
        16usize,
        concat!("Size of: ", stringify!(NError))
    );
    assert_eq!(
        ::std::mem::align_of::<NError>(),
        8usize,
        concat!("Alignment of ", stringify!(NError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NError>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NError),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NError>())).code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NError),
            "::",
            stringify!(code)
        )
    );
}
pub type sNError = NError;
extern "C" {
    pub fn NErrorCode_toString(code: tNErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NError_toString(error: *const sNError) -> *const ::std::os::raw::c_char;
}
#[doc = " A user in the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUser {
    #[doc = "< The id of the user's account."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< The username of the user's account."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = "< The display name of the user."]
    pub displayName: *const ::std::os::raw::c_char,
    #[doc = "< A URL for an avatar image."]
    pub avatarUrl: *const ::std::os::raw::c_char,
    #[doc = "< The language expected to be a tag which follows the BCP-47 spec."]
    pub lang: *const ::std::os::raw::c_char,
    #[doc = "< The location set by the user."]
    pub location: *const ::std::os::raw::c_char,
    #[doc = "< The timezone set by the user."]
    pub timeZone: *const ::std::os::raw::c_char,
    #[doc = "< Additional information stored as a JSON object."]
    pub metadata: *const ::std::os::raw::c_char,
    #[doc = "< The Facebook id in the user's account."]
    pub facebookId: *const ::std::os::raw::c_char,
    #[doc = "< The Google id in the user's account."]
    pub googleId: *const ::std::os::raw::c_char,
    #[doc = "< The Apple Game Center in of the user's account."]
    pub gameCenterId: *const ::std::os::raw::c_char,
    #[doc = "< The Apple Sign In ID in the user's account."]
    pub appleId: *const ::std::os::raw::c_char,
    #[doc = "< The Steam id in the user's account."]
    pub steamId: *const ::std::os::raw::c_char,
    #[doc = "< Indicates whether the user is currently online."]
    pub online: bool_,
    #[doc = "< Number of related edges to this user (friends)."]
    pub edgeCount: i32,
    #[doc = "< The UNIX time when the user was created."]
    pub createdAt: NTimestamp,
    #[doc = "< The UNIX time when the user was last updated."]
    pub updatedAt: NTimestamp,
}
#[test]
fn bindgen_test_layout_NUser() {
    assert_eq!(
        ::std::mem::size_of::<NUser>(),
        128usize,
        concat!("Size of: ", stringify!(NUser))
    );
    assert_eq!(
        ::std::mem::align_of::<NUser>(),
        8usize,
        concat!("Alignment of ", stringify!(NUser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(NUser), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).username as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).displayName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(displayName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).avatarUrl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(avatarUrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).lang as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).timeZone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(timeZone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).metadata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).facebookId as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(facebookId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).googleId as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(googleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).gameCenterId as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(gameCenterId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).appleId as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(appleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).steamId as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(steamId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).online as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(online)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).edgeCount as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(edgeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).createdAt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(createdAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUser>())).updatedAt as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(NUser),
            "::",
            stringify!(updatedAt)
        )
    );
}
#[doc = " A user in the server."]
pub type sNUser = NUser;
#[doc = " Used with authenticate/link/unlink and user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAccountDevice {
    #[doc = "< A device identifier. Should be obtained by a platform-specific device API."]
    pub id: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NAccountDevice() {
    assert_eq!(
        ::std::mem::size_of::<NAccountDevice>(),
        8usize,
        concat!("Size of: ", stringify!(NAccountDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<NAccountDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(NAccountDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccountDevice>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccountDevice),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " Used with authenticate/link/unlink and user."]
pub type sNAccountDevice = NAccountDevice;
#[doc = " A user with additional account details. Always the current user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAccount {
    #[doc = "< The user object."]
    pub user: sNUser,
    #[doc = "< The user's wallet data."]
    pub wallet: *const ::std::os::raw::c_char,
    #[doc = "< The email address of the user."]
    pub email: *const ::std::os::raw::c_char,
    #[doc = "< The devices which belong to the user's account."]
    pub devices: *mut sNAccountDevice,
    #[doc = "< The devices count."]
    pub devicesCount: u16,
    #[doc = "< The custom id in the user's account."]
    pub customId: *const ::std::os::raw::c_char,
    #[doc = "< The UNIX time when the user's email was verified."]
    pub verifyTime: NTimestamp,
    #[doc = "< The UNIX time when the user's account was disabled/banned."]
    pub disableTime: NTimestamp,
}
#[test]
fn bindgen_test_layout_NAccount() {
    assert_eq!(
        ::std::mem::size_of::<NAccount>(),
        184usize,
        concat!("Size of: ", stringify!(NAccount))
    );
    assert_eq!(
        ::std::mem::align_of::<NAccount>(),
        8usize,
        concat!("Alignment of ", stringify!(NAccount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).wallet as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(wallet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).email as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).devices as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).devicesCount as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(devicesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).customId as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(customId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).verifyTime as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(verifyTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NAccount>())).disableTime as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NAccount),
            "::",
            stringify!(disableTime)
        )
    );
}
#[doc = " A user with additional account details. Always the current user."]
pub type sNAccount = NAccount;
#[doc = " A group in the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NGroup {
    #[doc = "< The id of a group."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< The id of the user who created the group."]
    pub creatorId: *const ::std::os::raw::c_char,
    #[doc = "< The unique name of the group."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< A description for the group."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "< The language expected to be a tag which follows the BCP-47 spec."]
    pub lang: *const ::std::os::raw::c_char,
    #[doc = "< Additional information stored as a JSON object."]
    pub metadata: *const ::std::os::raw::c_char,
    #[doc = "< A URL for an avatar image."]
    pub avatarUrl: *const ::std::os::raw::c_char,
    #[doc = "< Anyone can join open groups, otherwise only admins can accept members."]
    pub open: bool_,
    #[doc = "< The current count of all members in the group."]
    pub edgeCount: i32,
    #[doc = "< The maximum number of members allowed."]
    pub maxCount: i32,
    #[doc = "< The UNIX time when the group was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the group was last updated."]
    pub updateTime: NTimestamp,
}
#[test]
fn bindgen_test_layout_NGroup() {
    assert_eq!(
        ::std::mem::size_of::<NGroup>(),
        88usize,
        concat!("Size of: ", stringify!(NGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<NGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(NGroup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).creatorId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(creatorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).lang as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).metadata as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).avatarUrl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(avatarUrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).open as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).edgeCount as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(edgeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).maxCount as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(maxCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).createTime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroup>())).updateTime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroup),
            "::",
            stringify!(updateTime)
        )
    );
}
#[doc = " A group in the server."]
pub type sNGroup = NGroup;
#[doc = " One or more groups returned from a listing operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NGroupList {
    #[doc = "< One or more groups."]
    pub groups: *mut sNGroup,
    #[doc = "< One or more groups."]
    pub groupsCount: u16,
    #[doc = "< A cursor used to get the next page."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NGroupList() {
    assert_eq!(
        ::std::mem::size_of::<NGroupList>(),
        24usize,
        concat!("Size of: ", stringify!(NGroupList))
    );
    assert_eq!(
        ::std::mem::align_of::<NGroupList>(),
        8usize,
        concat!("Alignment of ", stringify!(NGroupList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupList>())).groups as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupList),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupList>())).groupsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupList),
            "::",
            stringify!(groupsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupList),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " One or more groups returned from a listing operation."]
pub type sNGroupList = NGroupList;
#[doc = " A single user-role pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NGroupUser {
    #[doc = "< User."]
    pub user: sNUser,
    #[doc = "< Their relationship to the group."]
    pub state: eNUserGroupState,
}
#[test]
fn bindgen_test_layout_NGroupUser() {
    assert_eq!(
        ::std::mem::size_of::<NGroupUser>(),
        136usize,
        concat!("Size of: ", stringify!(NGroupUser))
    );
    assert_eq!(
        ::std::mem::align_of::<NGroupUser>(),
        8usize,
        concat!("Alignment of ", stringify!(NGroupUser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupUser>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupUser),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupUser>())).state as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupUser),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " A single user-role pair."]
pub type sNGroupUser = NGroupUser;
#[doc = " A list of users belonging to a group, along with their role."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NGroupUserList {
    #[doc = "< User-role pairs for a group."]
    pub groupUsers: *mut sNGroupUser,
    pub groupUsersCount: u16,
    #[doc = "< Cursor for the next page of results, if any."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NGroupUserList() {
    assert_eq!(
        ::std::mem::size_of::<NGroupUserList>(),
        24usize,
        concat!("Size of: ", stringify!(NGroupUserList))
    );
    assert_eq!(
        ::std::mem::align_of::<NGroupUserList>(),
        8usize,
        concat!("Alignment of ", stringify!(NGroupUserList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupUserList>())).groupUsers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupUserList),
            "::",
            stringify!(groupUsers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupUserList>())).groupUsersCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupUserList),
            "::",
            stringify!(groupUsersCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NGroupUserList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NGroupUserList),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " A list of users belonging to a group, along with their role."]
pub type sNGroupUserList = NGroupUserList;
#[doc = " A collection of zero or more users."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUsers {
    pub users: *mut sNUser,
    pub usersCount: u16,
}
#[test]
fn bindgen_test_layout_NUsers() {
    assert_eq!(
        ::std::mem::size_of::<NUsers>(),
        16usize,
        concat!("Size of: ", stringify!(NUsers))
    );
    assert_eq!(
        ::std::mem::align_of::<NUsers>(),
        8usize,
        concat!("Alignment of ", stringify!(NUsers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUsers>())).users as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NUsers),
            "::",
            stringify!(users)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUsers>())).usersCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NUsers),
            "::",
            stringify!(usersCount)
        )
    );
}
#[doc = " A collection of zero or more users."]
pub type sNUsers = NUsers;
#[doc = " A single group-role pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUserGroup {
    #[doc = "< Group."]
    pub group: sNGroup,
    #[doc = "< The user's relationship to the group."]
    pub state: eNUserGroupState,
}
#[test]
fn bindgen_test_layout_NUserGroup() {
    assert_eq!(
        ::std::mem::size_of::<NUserGroup>(),
        96usize,
        concat!("Size of: ", stringify!(NUserGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<NUserGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(NUserGroup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserGroup>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserGroup),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserGroup>())).state as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserGroup),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " A single group-role pair."]
pub type sNUserGroup = NUserGroup;
#[doc = " A list of groups belonging to a user, along with the user's role in each group."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUserGroupList {
    #[doc = "< Group-role pairs for a user."]
    pub userGroups: *mut sNUserGroup,
    pub userGroupsCount: u16,
    #[doc = "< Cursor for the next page of results, if any."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NUserGroupList() {
    assert_eq!(
        ::std::mem::size_of::<NUserGroupList>(),
        24usize,
        concat!("Size of: ", stringify!(NUserGroupList))
    );
    assert_eq!(
        ::std::mem::align_of::<NUserGroupList>(),
        8usize,
        concat!("Alignment of ", stringify!(NUserGroupList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserGroupList>())).userGroups as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserGroupList),
            "::",
            stringify!(userGroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserGroupList>())).userGroupsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserGroupList),
            "::",
            stringify!(userGroupsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserGroupList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserGroupList),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " A list of groups belonging to a user, along with the user's role in each group."]
pub type sNUserGroupList = NUserGroupList;
#[doc = "< The user is a friend of the current user."]
pub const FriendState_STATE_FRIEND: FriendState = 0;
#[doc = "< The current user has sent an invite to the user."]
pub const FriendState_STATE_INVITE_SENT: FriendState = 1;
#[doc = "< The current user has received an invite from this user."]
pub const FriendState_STATE_INVITE_RECEIVED: FriendState = 2;
#[doc = "< The current user has blocked this user."]
pub const FriendState_STATE_BLOCKED: FriendState = 3;
#[doc = " The friendship status."]
pub type FriendState = ::std::os::raw::c_uint;
#[doc = " The friendship status."]
pub use self::FriendState as eFriendState;
#[doc = " A friend of a user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFriend {
    #[doc = "< The user object."]
    pub user: sNUser,
    #[doc = "< The friend status."]
    pub state: eFriendState,
    #[doc = "< Time of the latest relationship update."]
    pub updateTime: NTimestamp,
}
#[test]
fn bindgen_test_layout_NFriend() {
    assert_eq!(
        ::std::mem::size_of::<NFriend>(),
        144usize,
        concat!("Size of: ", stringify!(NFriend))
    );
    assert_eq!(
        ::std::mem::align_of::<NFriend>(),
        8usize,
        concat!("Alignment of ", stringify!(NFriend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriend>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriend),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriend>())).state as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriend),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriend>())).updateTime as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriend),
            "::",
            stringify!(updateTime)
        )
    );
}
#[doc = " A friend of a user."]
pub type sNFriend = NFriend;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFriendList {
    #[doc = "< The Friend objects."]
    pub friends: *mut sNFriend,
    pub friendsCount: u16,
    #[doc = "< Cursor for the next page of results, if any."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NFriendList() {
    assert_eq!(
        ::std::mem::size_of::<NFriendList>(),
        24usize,
        concat!("Size of: ", stringify!(NFriendList))
    );
    assert_eq!(
        ::std::mem::align_of::<NFriendList>(),
        8usize,
        concat!("Alignment of ", stringify!(NFriendList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriendList>())).friends as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriendList),
            "::",
            stringify!(friends)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriendList>())).friendsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriendList),
            "::",
            stringify!(friendsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NFriendList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NFriendList),
            "::",
            stringify!(cursor)
        )
    );
}
pub type sNFriendList = NFriendList;
#[doc = " Represents a complete leaderboard record with all scores and associated metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NLeaderboardRecord {
    #[doc = "< The ID of the leaderboard this score belongs to."]
    pub leaderboardId: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the score owner, usually a user or group."]
    pub ownerId: *const ::std::os::raw::c_char,
    #[doc = "< The username of the score owner, if the owner is a user."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = "< The score value."]
    pub score: i64,
    #[doc = "< An optional subscore value."]
    pub subscore: i64,
    #[doc = "< The number of submissions to this score record."]
    pub numScore: i32,
    #[doc = "< The maximum number of score updates allowed by the owner."]
    pub maxNumScore: u32,
    #[doc = "< Metadata."]
    pub metadata: *const ::std::os::raw::c_char,
    #[doc = "< The UNIX time when the leaderboard record was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the leaderboard record was updated."]
    pub updateTime: NTimestamp,
    #[doc = "< The UNIX time when the leaderboard record expires."]
    pub expiryTime: NTimestamp,
    #[doc = "< The rank of this record."]
    pub rank: i64,
}
#[test]
fn bindgen_test_layout_NLeaderboardRecord() {
    assert_eq!(
        ::std::mem::size_of::<NLeaderboardRecord>(),
        88usize,
        concat!("Size of: ", stringify!(NLeaderboardRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<NLeaderboardRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(NLeaderboardRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecord>())).leaderboardId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(leaderboardId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).ownerId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(ownerId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).username as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).score as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).subscore as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(subscore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).numScore as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(numScore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).maxNumScore as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(maxNumScore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).metadata as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).createTime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).updateTime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(updateTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).expiryTime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(expiryTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecord>())).rank as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecord),
            "::",
            stringify!(rank)
        )
    );
}
#[doc = " Represents a complete leaderboard record with all scores and associated metadata."]
pub type sNLeaderboardRecord = NLeaderboardRecord;
#[doc = " A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NLeaderboardRecordList {
    #[doc = "< A list of leaderboard records."]
    pub records: *mut sNLeaderboardRecord,
    pub recordsCount: u16,
    #[doc = "< A batched set of leaderboard records belonging to specified owners."]
    pub ownerRecords: *mut sNLeaderboardRecord,
    pub ownerRecordsCount: u16,
    #[doc = "< The cursor to send when retrieving the next page, if any."]
    pub nextCursor: *const ::std::os::raw::c_char,
    #[doc = "< The cursor to send when retrieving the previous page, if any."]
    pub prevCursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NLeaderboardRecordList() {
    assert_eq!(
        ::std::mem::size_of::<NLeaderboardRecordList>(),
        48usize,
        concat!("Size of: ", stringify!(NLeaderboardRecordList))
    );
    assert_eq!(
        ::std::mem::align_of::<NLeaderboardRecordList>(),
        8usize,
        concat!("Alignment of ", stringify!(NLeaderboardRecordList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NLeaderboardRecordList>())).records as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecordList>())).recordsCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(recordsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecordList>())).ownerRecords as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(ownerRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecordList>())).ownerRecordsCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(ownerRecordsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecordList>())).nextCursor as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(nextCursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NLeaderboardRecordList>())).prevCursor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NLeaderboardRecordList),
            "::",
            stringify!(prevCursor)
        )
    );
}
#[doc = " A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records."]
pub type sNLeaderboardRecordList = NLeaderboardRecordList;
#[doc = " A user session associated to a stream, usually through a list operation or a join/leave event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NUserPresence {
    #[doc = "< The user this presence belongs to."]
    pub userId: *const ::std::os::raw::c_char,
    #[doc = "< A unique session ID identifying the particular connection, because the user may have many."]
    pub sessionId: *const ::std::os::raw::c_char,
    #[doc = "< The username for display purposes."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = "< Whether this presence generates persistent data/messages, if applicable for the stream type."]
    pub persistence: bool_,
    #[doc = "< A user-set status message for this stream, if applicable."]
    pub status: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NUserPresence() {
    assert_eq!(
        ::std::mem::size_of::<NUserPresence>(),
        40usize,
        concat!("Size of: ", stringify!(NUserPresence))
    );
    assert_eq!(
        ::std::mem::align_of::<NUserPresence>(),
        8usize,
        concat!("Alignment of ", stringify!(NUserPresence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserPresence>())).userId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserPresence),
            "::",
            stringify!(userId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserPresence>())).sessionId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserPresence),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserPresence>())).username as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserPresence),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserPresence>())).persistence as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserPresence),
            "::",
            stringify!(persistence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NUserPresence>())).status as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NUserPresence),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " A user session associated to a stream, usually through a list operation or a join/leave event."]
pub type sNUserPresence = NUserPresence;
#[doc = " Represents a realtime match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatch {
    #[doc = "< The ID of the match, can be used to join."]
    pub matchId: *const ::std::os::raw::c_char,
    #[doc = "< True if it's an server-managed authoritative match, false otherwise."]
    pub authoritative: bool_,
    #[doc = "< Match label, if any."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = "< Current number of users in the match."]
    pub size: i32,
    #[doc = "< The users currently in the match."]
    pub presences: *mut sNUserPresence,
    #[doc = "< The users currently in the match."]
    pub presencesCount: u16,
    #[doc = "< A reference to the current user's presence in the match."]
    pub self_: sNUserPresence,
}
#[test]
fn bindgen_test_layout_NMatch() {
    assert_eq!(
        ::std::mem::size_of::<NMatch>(),
        88usize,
        concat!("Size of: ", stringify!(NMatch))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatch>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).matchId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(matchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).authoritative as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(authoritative)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).presences as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(presences)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).presencesCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(presencesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatch>())).self_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatch),
            "::",
            stringify!(self_)
        )
    );
}
#[doc = " Represents a realtime match."]
pub type sNMatch = NMatch;
#[doc = " A list of realtime matches."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchList {
    #[doc = "< A number of matches corresponding to a list operation."]
    pub matches: *mut sNMatch,
    pub matchesCount: u16,
}
#[test]
fn bindgen_test_layout_NMatchList() {
    assert_eq!(
        ::std::mem::size_of::<NMatchList>(),
        16usize,
        concat!("Size of: ", stringify!(NMatchList))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchList>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchList>())).matches as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchList),
            "::",
            stringify!(matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchList>())).matchesCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchList),
            "::",
            stringify!(matchesCount)
        )
    );
}
#[doc = " A list of realtime matches."]
pub type sNMatchList = NMatchList;
#[doc = " A notification in the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NNotification {
    #[doc = "< ID of the Notification."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< Subject of the notification."]
    pub subject: *const ::std::os::raw::c_char,
    #[doc = "< Content of the notification in JSON."]
    pub content: *const ::std::os::raw::c_char,
    #[doc = "< Category code for this notification."]
    pub code: i32,
    #[doc = "< ID of the sender, if a user. Otherwise 'null'."]
    pub senderId: *const ::std::os::raw::c_char,
    #[doc = "< The UNIX time when the notification was created."]
    pub createTime: NTimestamp,
    #[doc = "< True if this notification was persisted to the database."]
    pub persistent: bool_,
}
#[test]
fn bindgen_test_layout_NNotification() {
    assert_eq!(
        ::std::mem::size_of::<NNotification>(),
        56usize,
        concat!("Size of: ", stringify!(NNotification))
    );
    assert_eq!(
        ::std::mem::align_of::<NNotification>(),
        8usize,
        concat!("Alignment of ", stringify!(NNotification))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).subject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).content as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).code as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).senderId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(senderId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).createTime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotification>())).persistent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotification),
            "::",
            stringify!(persistent)
        )
    );
}
#[doc = " A notification in the server."]
pub type sNNotification = NNotification;
#[doc = " A collection of zero or more notifications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NNotificationList {
    #[doc = "< Collection of notifications."]
    pub notifications: *mut sNNotification,
    pub notificationsCount: u16,
    #[doc = "< Use this cursor to paginate notifications. Cache this to catch up to new notifications."]
    pub cacheableCursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NNotificationList() {
    assert_eq!(
        ::std::mem::size_of::<NNotificationList>(),
        24usize,
        concat!("Size of: ", stringify!(NNotificationList))
    );
    assert_eq!(
        ::std::mem::align_of::<NNotificationList>(),
        8usize,
        concat!("Alignment of ", stringify!(NNotificationList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NNotificationList>())).notifications as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotificationList),
            "::",
            stringify!(notifications)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NNotificationList>())).notificationsCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotificationList),
            "::",
            stringify!(notificationsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NNotificationList>())).cacheableCursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NNotificationList),
            "::",
            stringify!(cacheableCursor)
        )
    );
}
#[doc = " A collection of zero or more notifications."]
pub type sNNotificationList = NNotificationList;
#[doc = " A message sent on a channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NChannelMessage {
    #[doc = "< The channel this message belongs to."]
    pub channelId: *const ::std::os::raw::c_char,
    #[doc = "< The unique ID of this message."]
    pub messageId: *const ::std::os::raw::c_char,
    #[doc = "< The code representing a message type or category."]
    pub code: i32,
    #[doc = "< Message sender, usually a user ID."]
    pub senderId: *const ::std::os::raw::c_char,
    #[doc = "< The username of the message sender, if any."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = "< The content payload."]
    pub content: *const ::std::os::raw::c_char,
    #[doc = "< The UNIX time when the message was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the message was last updated."]
    pub updateTime: NTimestamp,
    #[doc = "< True if the message was persisted to the channel's history, false otherwise."]
    pub persistent: bool_,
    #[doc = "< The name of the chat room, or an empty string if this message was not sent through a chat room."]
    pub roomName: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the group, or an empty string if this message was not sent through a group channel."]
    pub groupId: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the first DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdOne: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the second DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdTwo: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NChannelMessage() {
    assert_eq!(
        ::std::mem::size_of::<NChannelMessage>(),
        104usize,
        concat!("Size of: ", stringify!(NChannelMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NChannelMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NChannelMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).channelId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(channelId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).messageId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(messageId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).code as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).senderId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(senderId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).username as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).content as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).createTime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).updateTime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(updateTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).persistent as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(persistent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).roomName as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(roomName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).groupId as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).userIdOne as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(userIdOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessage>())).userIdTwo as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessage),
            "::",
            stringify!(userIdTwo)
        )
    );
}
#[doc = " A message sent on a channel."]
pub type sNChannelMessage = NChannelMessage;
#[doc = " A list of channel messages, usually a result of a list operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NChannelMessageList {
    #[doc = "< A list of messages."]
    pub messages: *mut sNChannelMessage,
    #[doc = "< Messages count."]
    pub messagesCount: u16,
    #[doc = "< The cursor to send when retireving the next page, if any."]
    pub nextCursor: *const ::std::os::raw::c_char,
    #[doc = "< The cursor to send when retrieving the previous page, if any."]
    pub prevCursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NChannelMessageList() {
    assert_eq!(
        ::std::mem::size_of::<NChannelMessageList>(),
        32usize,
        concat!("Size of: ", stringify!(NChannelMessageList))
    );
    assert_eq!(
        ::std::mem::align_of::<NChannelMessageList>(),
        8usize,
        concat!("Alignment of ", stringify!(NChannelMessageList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageList>())).messages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageList),
            "::",
            stringify!(messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NChannelMessageList>())).messagesCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageList),
            "::",
            stringify!(messagesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageList>())).nextCursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageList),
            "::",
            stringify!(nextCursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageList>())).prevCursor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageList),
            "::",
            stringify!(prevCursor)
        )
    );
}
#[doc = " A list of channel messages, usually a result of a list operation."]
pub type sNChannelMessageList = NChannelMessageList;
#[doc = " A tournament on the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTournament {
    #[doc = "< The ID of the tournament."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< The title for the tournament."]
    pub title: *const ::std::os::raw::c_char,
    #[doc = "< The description of the tournament. May be blank."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "< The category of the tournament. e.g. \"vip\" could be category 1."]
    pub category: u32,
    #[doc = "< ASC or DESC sort mode of scores in the tournament."]
    pub sortOrder: u32,
    #[doc = "< The current number of players in the tournament."]
    pub size: u32,
    #[doc = "< The maximum number of players for the tournament."]
    pub maxSize: u32,
    #[doc = "< The maximum score updates allowed per player for the current tournament."]
    pub maxNumScore: u32,
    #[doc = "< True if the tournament is active and can enter. A computed value."]
    pub canEnter: bool_,
    #[doc = "< The UNIX time when the tournament was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the tournament will start."]
    pub startTime: NTimestamp,
    #[doc = "< The UNIX time when the tournament will be stopped."]
    pub endTime: NTimestamp,
    #[doc = "< The UNIX time when the tournament stops being active until next reset. A computed value."]
    pub endActive: u32,
    #[doc = "< The UNIX time when the tournament is next playable. A computed value."]
    pub nextReset: u32,
    #[doc = "< Duration of the tournament in seconds."]
    pub duration: u32,
    #[doc = "< The UNIX time when the tournament start being active. A computed value."]
    pub startActive: u32,
    #[doc = "< Additional information stored as a JSON object."]
    pub metadata: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NTournament() {
    assert_eq!(
        ::std::mem::size_of::<NTournament>(),
        96usize,
        concat!("Size of: ", stringify!(NTournament))
    );
    assert_eq!(
        ::std::mem::align_of::<NTournament>(),
        8usize,
        concat!("Alignment of ", stringify!(NTournament))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).title as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).description as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).category as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).sortOrder as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(sortOrder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).maxSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(maxSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).maxNumScore as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(maxNumScore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).canEnter as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(canEnter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).createTime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).startTime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).endTime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(endTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).endActive as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(endActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).nextReset as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(nextReset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).duration as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).startActive as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(startActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournament>())).metadata as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournament),
            "::",
            stringify!(metadata)
        )
    );
}
#[doc = " A tournament on the server."]
pub type sNTournament = NTournament;
#[doc = " A list of tournaments."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTournamentList {
    #[doc = "< The list of tournaments returned."]
    pub tournaments: *mut sNTournament,
    pub tournamentsCount: u16,
    #[doc = "< A pagination cursor (optional)."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NTournamentList() {
    assert_eq!(
        ::std::mem::size_of::<NTournamentList>(),
        24usize,
        concat!("Size of: ", stringify!(NTournamentList))
    );
    assert_eq!(
        ::std::mem::align_of::<NTournamentList>(),
        8usize,
        concat!("Alignment of ", stringify!(NTournamentList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournamentList>())).tournaments as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentList),
            "::",
            stringify!(tournaments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentList>())).tournamentsCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentList),
            "::",
            stringify!(tournamentsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournamentList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentList),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " A list of tournaments."]
pub type sNTournamentList = NTournamentList;
#[doc = " A set of tournament records which may be part of a tournament records page or a batch of individual records."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTournamentRecordList {
    #[doc = "< A list of tournament records."]
    pub records: *mut sNLeaderboardRecord,
    pub recordsCount: u16,
    #[doc = "< A batched set of tournament records belonging to specified owners."]
    pub ownerRecords: *mut sNLeaderboardRecord,
    pub ownerRecordsCount: u16,
    #[doc = "< The cursor to send when retireving the next page, if any."]
    pub nextCursor: *const ::std::os::raw::c_char,
    #[doc = "< The cursor to send when retrieving the previous page, if any."]
    pub prevCursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NTournamentRecordList() {
    assert_eq!(
        ::std::mem::size_of::<NTournamentRecordList>(),
        48usize,
        concat!("Size of: ", stringify!(NTournamentRecordList))
    );
    assert_eq!(
        ::std::mem::align_of::<NTournamentRecordList>(),
        8usize,
        concat!("Alignment of ", stringify!(NTournamentRecordList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NTournamentRecordList>())).records as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentRecordList>())).recordsCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(recordsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentRecordList>())).ownerRecords as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(ownerRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentRecordList>())).ownerRecordsCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(ownerRecordsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentRecordList>())).nextCursor as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(nextCursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NTournamentRecordList>())).prevCursor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NTournamentRecordList),
            "::",
            stringify!(prevCursor)
        )
    );
}
#[doc = " A set of tournament records which may be part of a tournament records page or a batch of individual records."]
pub type sNTournamentRecordList = NTournamentRecordList;
#[doc = "< The object is only readable by server runtime."]
pub const NStoragePermissionRead_NStoragePermissionRead_NO_READ: NStoragePermissionRead = 0;
#[doc = "< Only the user who owns it may access."]
pub const NStoragePermissionRead_NStoragePermissionRead_OWNER_READ: NStoragePermissionRead = 1;
#[doc = "< Any user can read the object."]
pub const NStoragePermissionRead_NStoragePermissionRead_PUBLIC_READ: NStoragePermissionRead = 2;
#[doc = " The read access permissions."]
pub type NStoragePermissionRead = ::std::os::raw::c_uint;
#[doc = " The read access permissions."]
pub use self::NStoragePermissionRead as eNStoragePermissionRead;
#[doc = "< The object is only writable by server runtime."]
pub const NStoragePermissionWrite_NStoragePermissionWrite_NO_WRITE: NStoragePermissionWrite = 0;
#[doc = "< Only the user who owns it may write."]
pub const NStoragePermissionWrite_NStoragePermissionWrite_OWNER_WRITE: NStoragePermissionWrite = 1;
#[doc = " The write access permissions."]
pub type NStoragePermissionWrite = ::std::os::raw::c_uint;
#[doc = " The write access permissions."]
pub use self::NStoragePermissionWrite as eNStoragePermissionWrite;
#[doc = " An object within the storage engine."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStorageObject {
    #[doc = "< The collection which stores the object."]
    pub collection: *const ::std::os::raw::c_char,
    #[doc = "< The key of the object within the collection."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = "< The user owner of the object."]
    pub userId: *const ::std::os::raw::c_char,
    #[doc = "< The value of the object."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = "< The version hash of the object."]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< The read access permissions for the object. Default is NStoragePermissionRead_NO_READ"]
    pub permissionRead: eNStoragePermissionRead,
    #[doc = "< The write access permissions for the object. Default is NStoragePermissionWrite_NO_WRITE"]
    pub permissionWrite: eNStoragePermissionWrite,
    #[doc = "< The UNIX time when the object was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the object was last updated."]
    pub updateTime: NTimestamp,
}
#[test]
fn bindgen_test_layout_NStorageObject() {
    assert_eq!(
        ::std::mem::size_of::<NStorageObject>(),
        64usize,
        concat!("Size of: ", stringify!(NStorageObject))
    );
    assert_eq!(
        ::std::mem::align_of::<NStorageObject>(),
        8usize,
        concat!("Alignment of ", stringify!(NStorageObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).collection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).userId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(userId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).permissionRead as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(permissionRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).permissionWrite as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(permissionWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).createTime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObject>())).updateTime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObject),
            "::",
            stringify!(updateTime)
        )
    );
}
#[doc = " An object within the storage engine."]
pub type sNStorageObject = NStorageObject;
#[doc = " List of storage objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStorageObjectList {
    #[doc = "< The list of storage objects."]
    pub objects: *mut sNStorageObject,
    pub objectsCount: u16,
    #[doc = "< The cursor for the next page of results, if any."]
    pub cursor: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStorageObjectList() {
    assert_eq!(
        ::std::mem::size_of::<NStorageObjectList>(),
        24usize,
        concat!("Size of: ", stringify!(NStorageObjectList))
    );
    assert_eq!(
        ::std::mem::align_of::<NStorageObjectList>(),
        8usize,
        concat!("Alignment of ", stringify!(NStorageObjectList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectList>())).objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectList),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectList>())).objectsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectList),
            "::",
            stringify!(objectsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectList>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectList),
            "::",
            stringify!(cursor)
        )
    );
}
#[doc = " List of storage objects."]
pub type sNStorageObjectList = NStorageObjectList;
#[doc = " A storage acknowledgement."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStorageObjectAck {
    #[doc = "< The collection which stores the object."]
    pub collection: *const ::std::os::raw::c_char,
    #[doc = "< The key of the object within the collection."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = "< The version hash of the object."]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< The owner of the object."]
    pub userId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStorageObjectAck() {
    assert_eq!(
        ::std::mem::size_of::<NStorageObjectAck>(),
        32usize,
        concat!("Size of: ", stringify!(NStorageObjectAck))
    );
    assert_eq!(
        ::std::mem::align_of::<NStorageObjectAck>(),
        8usize,
        concat!("Alignment of ", stringify!(NStorageObjectAck))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectAck>())).collection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectAck),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectAck>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectAck),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectAck>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectAck),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectAck>())).userId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectAck),
            "::",
            stringify!(userId)
        )
    );
}
#[doc = " A storage acknowledgement."]
pub type sNStorageObjectAck = NStorageObjectAck;
#[doc = " The object to store."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStorageObjectWrite {
    #[doc = "< The collection which stores the object."]
    pub collection: *const ::std::os::raw::c_char,
    #[doc = "< The key of the object within the collection."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = "< The value of the object. Must be JSON"]
    pub value: *const ::std::os::raw::c_char,
    #[doc = "< The version hash of the object to check. Possible values are: [\"\", \"*\", \"#hash#\"]."]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< The read access permissions for the object. Optional."]
    pub permissionRead: *const eNStoragePermissionRead,
    #[doc = "< The write access permissions for the object. Optional."]
    pub permissionWrite: *const eNStoragePermissionWrite,
}
#[test]
fn bindgen_test_layout_NStorageObjectWrite() {
    assert_eq!(
        ::std::mem::size_of::<NStorageObjectWrite>(),
        48usize,
        concat!("Size of: ", stringify!(NStorageObjectWrite))
    );
    assert_eq!(
        ::std::mem::align_of::<NStorageObjectWrite>(),
        8usize,
        concat!("Alignment of ", stringify!(NStorageObjectWrite))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectWrite>())).collection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectWrite>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectWrite>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStorageObjectWrite>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NStorageObjectWrite>())).permissionRead as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(permissionRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NStorageObjectWrite>())).permissionWrite as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NStorageObjectWrite),
            "::",
            stringify!(permissionWrite)
        )
    );
}
#[doc = " The object to store."]
pub type sNStorageObjectWrite = NStorageObjectWrite;
#[doc = " Storage objects to get."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NReadStorageObjectId {
    #[doc = "< The collection which stores the object."]
    pub collection: *const ::std::os::raw::c_char,
    #[doc = "< The key of the object within the collection."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = "< The user owner of the object."]
    pub userId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NReadStorageObjectId() {
    assert_eq!(
        ::std::mem::size_of::<NReadStorageObjectId>(),
        24usize,
        concat!("Size of: ", stringify!(NReadStorageObjectId))
    );
    assert_eq!(
        ::std::mem::align_of::<NReadStorageObjectId>(),
        8usize,
        concat!("Alignment of ", stringify!(NReadStorageObjectId))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NReadStorageObjectId>())).collection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NReadStorageObjectId),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NReadStorageObjectId>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NReadStorageObjectId),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NReadStorageObjectId>())).userId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NReadStorageObjectId),
            "::",
            stringify!(userId)
        )
    );
}
#[doc = " Storage objects to get."]
pub type sNReadStorageObjectId = NReadStorageObjectId;
#[doc = " Storage objects to delete."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDeleteStorageObjectId {
    #[doc = "< The collection which stores the object."]
    pub collection: *const ::std::os::raw::c_char,
    #[doc = "< The key of the object within the collection."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = "< The version hash of the object."]
    pub version: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NDeleteStorageObjectId() {
    assert_eq!(
        ::std::mem::size_of::<NDeleteStorageObjectId>(),
        24usize,
        concat!("Size of: ", stringify!(NDeleteStorageObjectId))
    );
    assert_eq!(
        ::std::mem::align_of::<NDeleteStorageObjectId>(),
        8usize,
        concat!("Alignment of ", stringify!(NDeleteStorageObjectId))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NDeleteStorageObjectId>())).collection as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NDeleteStorageObjectId),
            "::",
            stringify!(collection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NDeleteStorageObjectId>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NDeleteStorageObjectId),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NDeleteStorageObjectId>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NDeleteStorageObjectId),
            "::",
            stringify!(version)
        )
    );
}
#[doc = " Storage objects to delete."]
pub type sNDeleteStorageObjectId = NDeleteStorageObjectId;
#[doc = " Execute an Lua function on the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NRpc {
    #[doc = "< The identifier of the function."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< The payload of the function which must be a JSON object."]
    pub payload: *const ::std::os::raw::c_char,
    #[doc = "< The authentication key used when executed as a non-client HTTP request."]
    pub httpKey: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NRpc() {
    assert_eq!(
        ::std::mem::size_of::<NRpc>(),
        24usize,
        concat!("Size of: ", stringify!(NRpc))
    );
    assert_eq!(
        ::std::mem::align_of::<NRpc>(),
        8usize,
        concat!("Alignment of ", stringify!(NRpc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRpc>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(NRpc), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRpc>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NRpc),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRpc>())).httpKey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NRpc),
            "::",
            stringify!(httpKey)
        )
    );
}
#[doc = " Execute an Lua function on the server."]
pub type sNRpc = NRpc;
#[doc = "< Connect has failed."]
pub const RtErrorCode_RtErrorCode_CONNECT_ERROR: RtErrorCode = -1;
#[doc = "< Transport error."]
pub const RtErrorCode_RtErrorCode_TRANSPORT_ERROR: RtErrorCode = -2;
#[doc = "< An unexpected result from the server."]
pub const RtErrorCode_RtErrorCode_RUNTIME_EXCEPTION: RtErrorCode = 0;
#[doc = "< The server received a message which is not recognised."]
pub const RtErrorCode_RtErrorCode_UNRECOGNIZED_PAYLOAD: RtErrorCode = 1;
#[doc = "< A message was expected but contains no content."]
pub const RtErrorCode_RtErrorCode_MISSING_PAYLOAD: RtErrorCode = 2;
#[doc = "< Fields in the message have an invalid format."]
pub const RtErrorCode_RtErrorCode_BAD_INPUT: RtErrorCode = 3;
#[doc = "< The match id was not found."]
pub const RtErrorCode_RtErrorCode_MATCH_NOT_FOUND: RtErrorCode = 4;
#[doc = "< The match join was rejected."]
pub const RtErrorCode_RtErrorCode_MATCH_JOIN_REJECTED: RtErrorCode = 5;
#[doc = "< The runtime function does not exist on the server."]
pub const RtErrorCode_RtErrorCode_RUNTIME_FUNCTION_NOT_FOUND: RtErrorCode = 6;
#[doc = "< The runtime function executed with an error."]
pub const RtErrorCode_RtErrorCode_RUNTIME_FUNCTION_EXCEPTION: RtErrorCode = 7;
#[doc = " The selection of possible error codes."]
pub type RtErrorCode = ::std::os::raw::c_int;
#[doc = " The selection of possible error codes."]
pub use self::RtErrorCode as eRtErrorCode;
#[doc = " A logical error which may occur on the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NRtError {
    #[doc = "< The error code"]
    pub code: eRtErrorCode,
    #[doc = "< A message in English to help developers debug the response."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = "< Additional error details which may be different for each response."]
    pub context: NStringMap,
}
#[test]
fn bindgen_test_layout_NRtError() {
    assert_eq!(
        ::std::mem::size_of::<NRtError>(),
        24usize,
        concat!("Size of: ", stringify!(NRtError))
    );
    assert_eq!(
        ::std::mem::align_of::<NRtError>(),
        8usize,
        concat!("Alignment of ", stringify!(NRtError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtError>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtError),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtError>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtError),
            "::",
            stringify!(context)
        )
    );
}
#[doc = " A logical error which may occur on the server."]
pub type sNRtError = NRtError;
extern "C" {
    pub fn RtErrorCode_toString(code: eRtErrorCode) -> *const ::std::os::raw::c_char;
}
#[doc = " A realtime chat channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NChannel {
    #[doc = "< The ID of the channel."]
    pub id: *const ::std::os::raw::c_char,
    #[doc = "< The users currently in the channel."]
    pub presences: *mut sNUserPresence,
    pub presencesCount: u16,
    #[doc = "< A reference to the current user's presence in the channel."]
    pub self_: sNUserPresence,
    #[doc = "< The name of the chat room, or an empty string if this message was not sent through a chat room."]
    pub roomName: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the group, or an empty string if this message was not sent through a group channel."]
    pub groupId: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the first DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdOne: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the second DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdTwo: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NChannel() {
    assert_eq!(
        ::std::mem::size_of::<NChannel>(),
        96usize,
        concat!("Size of: ", stringify!(NChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<NChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(NChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).presences as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(presences)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).presencesCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(presencesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).self_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).roomName as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(roomName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).groupId as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).userIdOne as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(userIdOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannel>())).userIdTwo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannel),
            "::",
            stringify!(userIdTwo)
        )
    );
}
#[doc = " A realtime chat channel."]
pub type sNChannel = NChannel;
#[doc = " A receipt reply from a channel message send operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NChannelMessageAck {
    #[doc = "< The channel the message was sent to."]
    pub channelId: *const ::std::os::raw::c_char,
    #[doc = "< The unique ID assigned to the message."]
    pub messageId: *const ::std::os::raw::c_char,
    #[doc = "< Username of the message sender."]
    pub username: *const ::std::os::raw::c_char,
    #[doc = "< The code representing a message type or category."]
    pub code: i32,
    #[doc = "< The UNIX time when the message was created."]
    pub createTime: NTimestamp,
    #[doc = "< The UNIX time when the message was last updated."]
    pub updateTime: NTimestamp,
    #[doc = "< True if the message was persisted to the channel's history, false otherwise."]
    pub persistent: bool_,
    #[doc = "< The name of the chat room, or an empty string if this message was not sent through a chat room."]
    pub roomName: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the group, or an empty string if this message was not sent through a group channel."]
    pub groupId: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the first DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdOne: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the second DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdTwo: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NChannelMessageAck() {
    assert_eq!(
        ::std::mem::size_of::<NChannelMessageAck>(),
        88usize,
        concat!("Size of: ", stringify!(NChannelMessageAck))
    );
    assert_eq!(
        ::std::mem::align_of::<NChannelMessageAck>(),
        8usize,
        concat!("Alignment of ", stringify!(NChannelMessageAck))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).channelId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(channelId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).messageId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(messageId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).username as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).code as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).createTime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(createTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).updateTime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(updateTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).persistent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(persistent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).roomName as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(roomName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).groupId as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).userIdOne as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(userIdOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelMessageAck>())).userIdTwo as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelMessageAck),
            "::",
            stringify!(userIdTwo)
        )
    );
}
#[doc = " A receipt reply from a channel message send operation."]
pub type sNChannelMessageAck = NChannelMessageAck;
#[doc = " A ticket representing a new matchmaking process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchmakerTicket {
    #[doc = "< The ticket that can be used to cancel matchmaking."]
    pub ticket: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NMatchmakerTicket() {
    assert_eq!(
        ::std::mem::size_of::<NMatchmakerTicket>(),
        8usize,
        concat!("Size of: ", stringify!(NMatchmakerTicket))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchmakerTicket>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchmakerTicket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerTicket>())).ticket as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerTicket),
            "::",
            stringify!(ticket)
        )
    );
}
#[doc = " A ticket representing a new matchmaking process."]
pub type sNMatchmakerTicket = NMatchmakerTicket;
#[doc = " A snapshot of statuses for some set of users."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStatus {
    #[doc = "< User statuses."]
    pub presences: *mut sNUserPresence,
    pub presencesCount: u16,
}
#[test]
fn bindgen_test_layout_NStatus() {
    assert_eq!(
        ::std::mem::size_of::<NStatus>(),
        16usize,
        concat!("Size of: ", stringify!(NStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<NStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(NStatus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStatus>())).presences as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatus),
            "::",
            stringify!(presences)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStatus>())).presencesCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatus),
            "::",
            stringify!(presencesCount)
        )
    );
}
#[doc = " A snapshot of statuses for some set of users."]
pub type sNStatus = NStatus;
#[doc = " A set of joins and leaves on a particular channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NChannelPresenceEvent {
    #[doc = "< The channel identifier this event is for."]
    pub channelId: *const ::std::os::raw::c_char,
    #[doc = "< Presences joining the channel as part of this event, if any."]
    pub joins: *mut sNUserPresence,
    pub joinsCount: u16,
    #[doc = "< Presences leaving the channel as part of this event, if any."]
    pub leaves: *mut sNUserPresence,
    pub leavesCount: u16,
    #[doc = "< The name of the chat room, or an empty string if this message was not sent through a chat room."]
    pub roomName: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the group, or an empty string if this message was not sent through a group channel."]
    pub groupId: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the first DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdOne: *const ::std::os::raw::c_char,
    #[doc = "< The ID of the second DM user, or an empty string if this message was not sent through a DM chat."]
    pub userIdTwo: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NChannelPresenceEvent() {
    assert_eq!(
        ::std::mem::size_of::<NChannelPresenceEvent>(),
        72usize,
        concat!("Size of: ", stringify!(NChannelPresenceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<NChannelPresenceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(NChannelPresenceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).channelId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(channelId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).joins as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(joins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NChannelPresenceEvent>())).joinsCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(joinsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).leaves as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(leaves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NChannelPresenceEvent>())).leavesCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(leavesCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).roomName as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(roomName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).groupId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(groupId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).userIdOne as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(userIdOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NChannelPresenceEvent>())).userIdTwo as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NChannelPresenceEvent),
            "::",
            stringify!(userIdTwo)
        )
    );
}
#[doc = " A set of joins and leaves on a particular channel."]
pub type sNChannelPresenceEvent = NChannelPresenceEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStringDoubleMap_ {
    pub c: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStringDoubleMap_() {
    assert_eq!(
        ::std::mem::size_of::<NStringDoubleMap_>(),
        1usize,
        concat!("Size of: ", stringify!(NStringDoubleMap_))
    );
    assert_eq!(
        ::std::mem::align_of::<NStringDoubleMap_>(),
        1usize,
        concat!("Alignment of ", stringify!(NStringDoubleMap_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStringDoubleMap_>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStringDoubleMap_),
            "::",
            stringify!(c)
        )
    );
}
pub type NStringDoubleMap = *mut NStringDoubleMap_;
extern "C" {
    #[doc = " Creates string map."]
    #[doc = ""]
    #[doc = " @return NStringDoubleMap."]
    pub fn NStringDoubleMap_create() -> NStringDoubleMap;
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param key The key. The key value will be overwritten if it already exists."]
    #[doc = " @param value The value of a key."]
    pub fn NStringDoubleMap_setValue(
        map: NStringDoubleMap,
        key: *const ::std::os::raw::c_char,
        value: f64,
    );
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param key The key to receive value for."]
    #[doc = " @param value The returned value of the key."]
    #[doc = " @return true if value found."]
    pub fn NStringDoubleMap_getValue(
        map: NStringDoubleMap,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> bool_;
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @param keysArray The output keys array. Allocate first."]
    pub fn NStringDoubleMap_getKeys(
        map: NStringDoubleMap,
        keysArray: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @param map The string map."]
    #[doc = " @return size of the map."]
    pub fn NStringDoubleMap_getSize(map: NStringDoubleMap) -> u16;
}
extern "C" {
    #[doc = " Destroy a string map."]
    #[doc = ""]
    #[doc = " @param map The string map."]
    pub fn NStringDoubleMap_destroy(map: NStringDoubleMap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchmakerUser {
    #[doc = "< User info."]
    pub presence: sNUserPresence,
    #[doc = "< String properties."]
    pub stringProperties: NStringMap,
    #[doc = "< Numeric properties."]
    pub numericProperties: NStringDoubleMap,
}
#[test]
fn bindgen_test_layout_NMatchmakerUser() {
    assert_eq!(
        ::std::mem::size_of::<NMatchmakerUser>(),
        56usize,
        concat!("Size of: ", stringify!(NMatchmakerUser))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchmakerUser>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchmakerUser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerUser>())).presence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerUser),
            "::",
            stringify!(presence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMatchmakerUser>())).stringProperties as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerUser),
            "::",
            stringify!(stringProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NMatchmakerUser>())).numericProperties as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerUser),
            "::",
            stringify!(numericProperties)
        )
    );
}
pub type sNMatchmakerUser = NMatchmakerUser;
#[doc = " A successful matchmaking result."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchmakerMatched {
    #[doc = "< The matchmaking ticket that has completed."]
    #[doc = "< The match token or match ID to join."]
    pub ticket: *const ::std::os::raw::c_char,
    #[doc = "< Match ID."]
    pub matchId: *const ::std::os::raw::c_char,
    #[doc = "< Match join token."]
    pub token: *const ::std::os::raw::c_char,
    #[doc = "< The users that have been matched together, and information about their matchmaking data."]
    pub users: *mut sNMatchmakerUser,
    pub usersCount: u16,
    #[doc = "< A reference to the current user and their properties."]
    pub self_: sNMatchmakerUser,
}
#[test]
fn bindgen_test_layout_NMatchmakerMatched() {
    assert_eq!(
        ::std::mem::size_of::<NMatchmakerMatched>(),
        96usize,
        concat!("Size of: ", stringify!(NMatchmakerMatched))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchmakerMatched>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchmakerMatched))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).ticket as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(ticket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).matchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(matchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).token as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).users as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(users)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).usersCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(usersCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchmakerMatched>())).self_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchmakerMatched),
            "::",
            stringify!(self_)
        )
    );
}
#[doc = " A successful matchmaking result."]
pub type sNMatchmakerMatched = NMatchmakerMatched;
#[doc = " Realtime match data received from the server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchData {
    #[doc = "< The match unique ID."]
    pub matchId: *const ::std::os::raw::c_char,
    #[doc = "< A reference to the user presence that sent this data, if any."]
    pub presence: sNUserPresence,
    #[doc = "< Op code value."]
    pub opCode: i64,
    #[doc = "< Data payload, if any."]
    pub data: sNBytes,
}
#[test]
fn bindgen_test_layout_NMatchData() {
    assert_eq!(
        ::std::mem::size_of::<NMatchData>(),
        72usize,
        concat!("Size of: ", stringify!(NMatchData))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchData>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchData>())).matchId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchData),
            "::",
            stringify!(matchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchData>())).presence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchData),
            "::",
            stringify!(presence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchData>())).opCode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchData),
            "::",
            stringify!(opCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchData>())).data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchData),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Realtime match data received from the server."]
pub type sNMatchData = NMatchData;
#[doc = " A set of joins and leaves on a particular realtime match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NMatchPresenceEvent {
    pub matchId: *const ::std::os::raw::c_char,
    #[doc = " The match unique ID."]
    pub joins: *mut sNUserPresence,
    #[doc = " User presences that have just joined the match."]
    pub joinsCount: u16,
    pub leaves: *mut sNUserPresence,
    #[doc = " User presences that have just left the match."]
    pub leavesCount: u16,
}
#[test]
fn bindgen_test_layout_NMatchPresenceEvent() {
    assert_eq!(
        ::std::mem::size_of::<NMatchPresenceEvent>(),
        40usize,
        concat!("Size of: ", stringify!(NMatchPresenceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<NMatchPresenceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(NMatchPresenceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchPresenceEvent>())).matchId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchPresenceEvent),
            "::",
            stringify!(matchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchPresenceEvent>())).joins as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchPresenceEvent),
            "::",
            stringify!(joins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchPresenceEvent>())).joinsCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchPresenceEvent),
            "::",
            stringify!(joinsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchPresenceEvent>())).leaves as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchPresenceEvent),
            "::",
            stringify!(leaves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NMatchPresenceEvent>())).leavesCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NMatchPresenceEvent),
            "::",
            stringify!(leavesCount)
        )
    );
}
#[doc = " A set of joins and leaves on a particular realtime match."]
pub type sNMatchPresenceEvent = NMatchPresenceEvent;
#[doc = " A batch of status updates for a given user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStatusPresenceEvent {
    #[doc = "< New statuses for the user."]
    pub joins: *mut sNUserPresence,
    pub joinsCount: u16,
    #[doc = "< Previous statuses for the user."]
    pub leaves: *mut sNUserPresence,
    pub leavesCount: u16,
}
#[test]
fn bindgen_test_layout_NStatusPresenceEvent() {
    assert_eq!(
        ::std::mem::size_of::<NStatusPresenceEvent>(),
        32usize,
        concat!("Size of: ", stringify!(NStatusPresenceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<NStatusPresenceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(NStatusPresenceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStatusPresenceEvent>())).joins as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatusPresenceEvent),
            "::",
            stringify!(joins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStatusPresenceEvent>())).joinsCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatusPresenceEvent),
            "::",
            stringify!(joinsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStatusPresenceEvent>())).leaves as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatusPresenceEvent),
            "::",
            stringify!(leaves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NStatusPresenceEvent>())).leavesCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NStatusPresenceEvent),
            "::",
            stringify!(leavesCount)
        )
    );
}
#[doc = " A batch of status updates for a given user."]
pub type sNStatusPresenceEvent = NStatusPresenceEvent;
#[doc = " Represents identifying information for a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStream {
    #[doc = "< Mode identifies the type of stream."]
    pub mode: i32,
    #[doc = "< Subject is the primary identifier, if any."]
    pub subject: *const ::std::os::raw::c_char,
    #[doc = "< Subcontext is a secondary identifier, if any."]
    pub subcontext: *const ::std::os::raw::c_char,
    #[doc = "< The label is an arbitrary identifying string, if the stream has one."]
    pub label: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStream() {
    assert_eq!(
        ::std::mem::size_of::<NStream>(),
        32usize,
        concat!("Size of: ", stringify!(NStream))
    );
    assert_eq!(
        ::std::mem::align_of::<NStream>(),
        8usize,
        concat!("Alignment of ", stringify!(NStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStream>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStream),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStream>())).subject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NStream),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStream>())).subcontext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NStream),
            "::",
            stringify!(subcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStream>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NStream),
            "::",
            stringify!(label)
        )
    );
}
#[doc = " Represents identifying information for a stream."]
pub type sNStream = NStream;
#[doc = " A set of joins and leaves on a particular stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStreamPresenceEvent {
    #[doc = "< The stream this event relates to."]
    pub stream: sNStream,
    #[doc = "< Presences joining the stream as part of this event, if any."]
    pub joins: *mut sNUserPresence,
    pub joinsCount: u16,
    #[doc = "< Presences leaving the stream as part of this event, if any."]
    pub leaves: *mut sNUserPresence,
    pub leavesCount: u16,
}
#[test]
fn bindgen_test_layout_NStreamPresenceEvent() {
    assert_eq!(
        ::std::mem::size_of::<NStreamPresenceEvent>(),
        64usize,
        concat!("Size of: ", stringify!(NStreamPresenceEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<NStreamPresenceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(NStreamPresenceEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamPresenceEvent>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamPresenceEvent),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamPresenceEvent>())).joins as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamPresenceEvent),
            "::",
            stringify!(joins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamPresenceEvent>())).joinsCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamPresenceEvent),
            "::",
            stringify!(joinsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamPresenceEvent>())).leaves as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamPresenceEvent),
            "::",
            stringify!(leaves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NStreamPresenceEvent>())).leavesCount as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamPresenceEvent),
            "::",
            stringify!(leavesCount)
        )
    );
}
#[doc = " A set of joins and leaves on a particular stream."]
pub type sNStreamPresenceEvent = NStreamPresenceEvent;
#[doc = " A data message delivered over a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NStreamData {
    #[doc = "< The stream this data message relates to."]
    pub stream: sNStream,
    #[doc = "< The sender, if any."]
    pub sender: sNUserPresence,
    #[doc = "< Arbitrary contents of the data message."]
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NStreamData() {
    assert_eq!(
        ::std::mem::size_of::<NStreamData>(),
        80usize,
        concat!("Size of: ", stringify!(NStreamData))
    );
    assert_eq!(
        ::std::mem::align_of::<NStreamData>(),
        8usize,
        concat!("Alignment of ", stringify!(NStreamData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamData>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamData),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamData>())).sender as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamData),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NStreamData>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NStreamData),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " A data message delivered over a stream."]
pub type sNStreamData = NStreamData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NRtClientDisconnectInfo {
    #[doc = " close code."]
    #[doc = " https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"]
    pub code: u16,
    #[doc = " close reason. Optional."]
    pub reason: *const ::std::os::raw::c_char,
    #[doc = " true if close was initiated by server."]
    pub remote: bool_,
}
#[test]
fn bindgen_test_layout_NRtClientDisconnectInfo() {
    assert_eq!(
        ::std::mem::size_of::<NRtClientDisconnectInfo>(),
        24usize,
        concat!("Size of: ", stringify!(NRtClientDisconnectInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NRtClientDisconnectInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NRtClientDisconnectInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtClientDisconnectInfo>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtClientDisconnectInfo),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtClientDisconnectInfo>())).reason as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtClientDisconnectInfo),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtClientDisconnectInfo>())).remote as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtClientDisconnectInfo),
            "::",
            stringify!(remote)
        )
    );
}
pub type sNRtClientDisconnectInfo = NRtClientDisconnectInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NRtClient_ {
    pub c: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NRtClient_() {
    assert_eq!(
        ::std::mem::size_of::<NRtClient_>(),
        1usize,
        concat!("Size of: ", stringify!(NRtClient_))
    );
    assert_eq!(
        ::std::mem::align_of::<NRtClient_>(),
        1usize,
        concat!("Alignment of ", stringify!(NRtClient_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NRtClient_>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NRtClient_),
            "::",
            stringify!(c)
        )
    );
}
pub type NRtClient = *mut NRtClient_;
pub type NRtClientReqData = *mut ::std::os::raw::c_void;
pub type NRtClientErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(client: NRtClient, reqData: NRtClientReqData, arg1: *const sNRtError),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RtClientParameters {
    #[doc = " The host address of the server. Use \"127.0.0.1\" for local server."]
    pub host: *const ::std::os::raw::c_char,
    #[doc = " The port number of the server."]
    #[doc = " Set NDEFAULT_PORT to use default port: 7350 for non-SSL connection, 443 for SSL."]
    pub port: i32,
    #[doc = " Set connection strings to use the secure mode with the server."]
    #[doc = " The server must be configured to make use of this option. With HTTP, GRPC, and WebSockets the server must"]
    #[doc = " be configured with an SSL certificate or use a load balancer which performs SSL termination."]
    #[doc = " For rUDP you must configure the server to expose it's IP address so it can be bundled within session tokens."]
    #[doc = " See the server documentation for more information."]
    pub ssl: bool_,
}
#[test]
fn bindgen_test_layout_RtClientParameters() {
    assert_eq!(
        ::std::mem::size_of::<RtClientParameters>(),
        16usize,
        concat!("Size of: ", stringify!(RtClientParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<RtClientParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(RtClientParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RtClientParameters>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtClientParameters),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RtClientParameters>())).port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtClientParameters),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RtClientParameters>())).ssl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtClientParameters),
            "::",
            stringify!(ssl)
        )
    );
}
pub type sRtClientParameters = RtClientParameters;
#[doc = " Protobuf binary protocol. It is recommented to use for production"]
#[doc = " as it's faster and uses less traffic for communication."]
#[doc = " Protobuf support is added in nakama server 2.3.0"]
pub const NRtClientProtocol_NRtClientProtocol_Protobuf: NRtClientProtocol = 0;
#[doc = " Json is text protocol. Might be useful for analyzing server traffic."]
pub const NRtClientProtocol_NRtClientProtocol_Json: NRtClientProtocol = 1;
pub type NRtClientProtocol = ::std::os::raw::c_uint;
pub use self::NRtClientProtocol as eNRtClientProtocol;
extern "C" {
    #[doc = " Pumps requests queue in your thread."]
    #[doc = " Call it periodically, each 50 ms is ok."]
    pub fn NRtClient_tick(client: NRtClient);
}
extern "C" {
    #[doc = " Set user data."]
    #[doc = ""]
    #[doc = " Client just holds this data so you can receive it later when you need it."]
    #[doc = ""]
    #[doc = " @param userData The user data."]
    pub fn NRtClient_setUserData(client: NRtClient, userData: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Get user data."]
    #[doc = ""]
    #[doc = " @return The user data."]
    pub fn NRtClient_getUserData(client: NRtClient) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Connect to the server."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param createStatus True if the socket should show the user as online to others."]
    #[doc = " @param protocol Communication protocol. Default is Protobuf."]
    pub fn NRtClient_connect(
        client: NRtClient,
        session: NSession,
        createStatus: bool_,
        protocol: eNRtClientProtocol,
    );
}
extern "C" {
    #[doc = " @return True if connected to server."]
    pub fn NRtClient_isConnected(client: NRtClient) -> bool_;
}
extern "C" {
    #[doc = " Close the connection with the server."]
    pub fn NRtClient_disconnect(client: NRtClient);
}
extern "C" {
    #[doc = " Join a chat channel on the server."]
    #[doc = ""]
    #[doc = " @param target The target channel to join."]
    #[doc = " @param type The type of channel to join."]
    #[doc = " @param persistence True if chat messages should be stored."]
    #[doc = " @param hidden True if the user should be hidden on the channel."]
    pub fn NRtClient_joinChat(
        client: NRtClient,
        target: *const ::std::os::raw::c_char,
        type_: eNChannelType,
        persistence: bool_,
        hidden: bool_,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNChannel),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Leave a chat channel on the server."]
    #[doc = ""]
    #[doc = " @param channelId The channel to leave."]
    pub fn NRtClient_leaveChat(
        client: NRtClient,
        channelId: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Send a chat message to a channel on the server."]
    #[doc = ""]
    #[doc = " @param channelId The channel to send on."]
    #[doc = " @param content The content of the chat message. Must be a JSON object."]
    pub fn NRtClient_writeChatMessage(
        client: NRtClient,
        channelId: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NRtClient,
                arg2: NRtClientReqData,
                arg3: *const sNChannelMessageAck,
            ),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Update a chat message to a channel on the server."]
    #[doc = ""]
    #[doc = " @param channelId The ID of the chat channel with the message."]
    #[doc = " @param messageId The ID of the message to update."]
    #[doc = " @param content The content update for the message. Must be a JSON object."]
    pub fn NRtClient_updateChatMessage(
        client: NRtClient,
        channelId: *const ::std::os::raw::c_char,
        messageId: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NRtClient,
                arg2: NRtClientReqData,
                arg3: *const sNChannelMessageAck,
            ),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Remove a chat message from a channel on the server."]
    #[doc = ""]
    #[doc = " @param channelId The chat channel with the message."]
    #[doc = " @param messageId The ID of a chat message to remove."]
    pub fn NRtClient_removeChatMessage(
        client: NRtClient,
        channelId: *const ::std::os::raw::c_char,
        messageId: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NRtClient,
                arg2: NRtClientReqData,
                arg3: *const sNChannelMessageAck,
            ),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Create a multiplayer match on the server."]
    pub fn NRtClient_createMatch(
        client: NRtClient,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNMatch),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Join a multiplayer match by ID."]
    #[doc = ""]
    #[doc = " @param matchId A match ID."]
    pub fn NRtClient_joinMatch(
        client: NRtClient,
        matchId: *const ::std::os::raw::c_char,
        metadata: NStringMap,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNMatch),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Join a multiplayer match with a matchmaker."]
    #[doc = ""]
    #[doc = " @param token A matchmaker ticket result object."]
    pub fn NRtClient_joinMatchByToken(
        client: NRtClient,
        token: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNMatch),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Leave a match on the server."]
    #[doc = ""]
    #[doc = " @param matchId The match to leave."]
    pub fn NRtClient_leaveMatch(
        client: NRtClient,
        matchId: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Join the matchmaker pool and search for opponents on the server."]
    #[doc = ""]
    #[doc = " @param minCount The minimum number of players to compete against."]
    #[doc = " @param maxCount The maximum number of players to compete against."]
    #[doc = " @param query A matchmaker query to search for opponents."]
    #[doc = " @param stringProperties A set of k/v properties to provide in searches."]
    #[doc = " @param numericProperties A set of k/v numeric properties to provide in searches."]
    pub fn NRtClient_addMatchmaker(
        client: NRtClient,
        minCount: i32,
        maxCount: i32,
        query: *const ::std::os::raw::c_char,
        stringProperties: NStringMap,
        numericProperties: NStringDoubleMap,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NRtClient,
                arg2: NRtClientReqData,
                arg3: *const sNMatchmakerTicket,
            ),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Leave the matchmaker pool by ticket."]
    #[doc = ""]
    #[doc = " @param ticket The ticket returned by the matchmaker on join. See <c>NMatchmakerTicket.ticket</c>."]
    pub fn NRtClient_removeMatchmaker(
        client: NRtClient,
        ticket: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Send a state change to a match on the server."]
    #[doc = ""]
    #[doc = " When no presences are supplied the new match state will be sent to all presences."]
    #[doc = ""]
    #[doc = " @param matchId The Id of the match."]
    #[doc = " @param opCode An operation code for the match state."]
    #[doc = " @param data The new state to send to the match."]
    #[doc = " @param presences The presences in the match to send the state."]
    pub fn NRtClient_sendMatchData(
        client: NRtClient,
        matchId: *const ::std::os::raw::c_char,
        opCode: i64,
        data: *const sNBytes,
        presences: *const sNUserPresence,
        presencesCount: u16,
    );
}
extern "C" {
    #[doc = " Follow one or more users for status updates."]
    #[doc = ""]
    #[doc = " @param userIds The user Ids to follow."]
    pub fn NRtClient_followUsers(
        client: NRtClient,
        userIds: *mut *const ::std::os::raw::c_char,
        userIdsCount: u16,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNStatus),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unfollow status updates for one or more users."]
    #[doc = ""]
    #[doc = " @param userIds The ids of users to unfollow."]
    pub fn NRtClient_unfollowUsers(
        client: NRtClient,
        userIds: *mut *const ::std::os::raw::c_char,
        userIdsCount: u16,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Update the user's status online."]
    #[doc = ""]
    #[doc = " @param status The new status of the user."]
    pub fn NRtClient_updateStatus(
        client: NRtClient,
        status: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Send an RPC message to the server."]
    #[doc = ""]
    #[doc = " @param id The ID of the function to execute."]
    #[doc = " @param payload The string content to send to the server."]
    pub fn NRtClient_rpc(
        client: NRtClient,
        id: *const ::std::os::raw::c_char,
        payload: *const ::std::os::raw::c_char,
        reqData: NRtClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, arg2: NRtClientReqData, arg3: *const sNRpc),
        >,
        errorCallback: NRtClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Called when the client socket has been connected."]
    pub fn NRtClient_setConnectCallback(
        client: NRtClient,
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: NRtClient)>,
    );
}
extern "C" {
    #[doc = " Called when the client socket disconnects."]
    pub fn NRtClient_setDisconnectCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, info: *const sNRtClientDisconnectInfo),
        >,
    );
}
extern "C" {
    #[doc = " Called when the client receives an error."]
    pub fn NRtClient_setErrorCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, error: *const sNRtError),
        >,
    );
}
extern "C" {
    #[doc = " Called when a new channel message has been received."]
    pub fn NRtClient_setChannelMessageCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, message: *const sNChannelMessage),
        >,
    );
}
extern "C" {
    #[doc = " Called when a new channel presence update has been received."]
    pub fn NRtClient_setChannelPresenceCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, presence: *const sNChannelPresenceEvent),
        >,
    );
}
extern "C" {
    #[doc = " Called when a matchmaking has found a match."]
    pub fn NRtClient_setMatchmakerMatchedCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, matched: *const sNMatchmakerMatched),
        >,
    );
}
extern "C" {
    #[doc = " Called when a new match data is received."]
    pub fn NRtClient_setMatchDataCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, matchData: *const sNMatchData),
        >,
    );
}
extern "C" {
    #[doc = " Called when a new match presence update is received."]
    pub fn NRtClient_setMatchPresenceCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, matchPresence: *const sNMatchPresenceEvent),
        >,
    );
}
extern "C" {
    #[doc = " Called when the client receives new notifications."]
    pub fn NRtClient_setNotificationsCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, notifications: *const sNNotificationList),
        >,
    );
}
extern "C" {
    #[doc = " Called when the client receives status presence updates."]
    pub fn NRtClient_setStatusPresenceCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, presence: *const sNStatusPresenceEvent),
        >,
    );
}
extern "C" {
    #[doc = " Called when the client receives stream presence updates."]
    pub fn NRtClient_setStreamPresenceCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, presence: *const sNStreamPresenceEvent),
        >,
    );
}
extern "C" {
    #[doc = " Called when the client receives stream data."]
    pub fn NRtClient_setStreamDataCallback(
        client: NRtClient,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NRtClient, data: *const sNStreamData),
        >,
    );
}
extern "C" {
    #[doc = " Destroys a realtime client."]
    #[doc = ""]
    #[doc = " @param client the realtime client"]
    pub fn NRtClient_destroy(client: NRtClient);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NClient_ {
    pub c: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NClient_() {
    assert_eq!(
        ::std::mem::size_of::<NClient_>(),
        1usize,
        concat!("Size of: ", stringify!(NClient_))
    );
    assert_eq!(
        ::std::mem::align_of::<NClient_>(),
        1usize,
        concat!("Alignment of ", stringify!(NClient_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NClient_>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NClient_),
            "::",
            stringify!(c)
        )
    );
}
pub type NClient = *mut NClient_;
pub type NClientReqData = *mut ::std::os::raw::c_void;
pub type NClientDefaultErrorCallback =
    ::std::option::Option<unsafe extern "C" fn(client: NClient, arg1: *const sNError)>;
pub type NClientErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(client: NClient, reqData: NClientReqData, arg1: *const sNError),
>;
pub type NSessionCallback = ::std::option::Option<
    unsafe extern "C" fn(client: NClient, reqData: NClientReqData, arg1: NSession),
>;
pub type NSuccessEmptyCallback =
    ::std::option::Option<unsafe extern "C" fn(client: NClient, reqData: NClientReqData)>;
extern "C" {
    #[doc = " Set default error callback."]
    #[doc = ""]
    #[doc = " Will be called if a request fails and no error callback was set for the request."]
    #[doc = ""]
    #[doc = " @param errorCallback The error callback."]
    pub fn NClient_setErrorCallback(client: NClient, errorCallback: NClientDefaultErrorCallback);
}
extern "C" {
    #[doc = " Set user data."]
    #[doc = ""]
    #[doc = " Client just holds this data so you can receive it later when you need it."]
    #[doc = ""]
    #[doc = " @param userData The user data."]
    pub fn NClient_setUserData(client: NClient, userData: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Get user data."]
    #[doc = ""]
    #[doc = " @return The user data."]
    pub fn NClient_getUserData(client: NClient) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Disconnects the client. This function kills all outgoing exchanges immediately without waiting."]
    pub fn NClient_disconnect(client: NClient);
}
extern "C" {
    #[doc = " Pumps requests queue in your thread."]
    #[doc = " Call it periodically, each 50 ms is ok."]
    pub fn NClient_tick(client: NClient);
}
extern "C" {
    #[doc = " Create a new real-time client with parameters from client."]
    #[doc = ""]
    #[doc = " @param port The port number of the server."]
    #[doc = "        Set NDEFAULT_PORT then: 7350 for non-SSL connection, 443 for SSL."]
    #[doc = " @return a new NRtClient instance."]
    pub fn NClient_createRtClient(client: NClient, port: i32) -> NRtClient;
}
extern "C" {
    #[doc = " Create a new real-time client with custom parameters."]
    #[doc = ""]
    #[doc = " @param parameters The real-time client parameters."]
    #[doc = " @return a new NRtClient instance."]
    pub fn NClient_createRtClientEx(
        client: NClient,
        parameters: *const sRtClientParameters,
    ) -> NRtClient;
}
extern "C" {
    #[doc = " Authenticate a user with a device id."]
    #[doc = ""]
    #[doc = " @param id A device identifier usually obtained from a platform API."]
    #[doc = " @param username A username used to create the user. Defaults to empty string."]
    #[doc = " @param create True if the user should be created when authenticated. Defaults to false."]
    pub fn NClient_authenticateDevice(
        client: NClient,
        id: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with an email and password."]
    #[doc = ""]
    #[doc = " @param email The email address of the user."]
    #[doc = " @param password The password for the user."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    pub fn NClient_authenticateEmail(
        client: NClient,
        email: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with a Facebook auth token."]
    #[doc = ""]
    #[doc = " @param accessToken An OAuth access token from the Facebook SDK."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    #[doc = " @param importFriends True if the Facebook friends should be imported."]
    pub fn NClient_authenticateFacebook(
        client: NClient,
        accessToken: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        importFriends: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with a Google auth token."]
    #[doc = ""]
    #[doc = " @param accessToken An OAuth access token from the Google SDK."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    pub fn NClient_authenticateGoogle(
        client: NClient,
        accessToken: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with Apple Game Center."]
    #[doc = ""]
    #[doc = " @param playerId The player id of the user in Game Center."]
    #[doc = " @param bundleId The bundle id of the Game Center application."]
    #[doc = " @param timestampSeconds The date and time that the signature was created."]
    #[doc = " @param salt A random <c>NSString</c> used to compute the hash and keep it randomized."]
    #[doc = " @param signature The verification signature data generated."]
    #[doc = " @param publicKeyUrl The URL for the public encryption key."]
    #[doc = " @param create True if the user should be created when authenticated."]
    #[doc = " @param username A username used to create the user."]
    pub fn NClient_authenticateGameCenter(
        client: NClient,
        playerId: *const ::std::os::raw::c_char,
        bundleId: *const ::std::os::raw::c_char,
        timestampSeconds: NTimestamp,
        salt: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_char,
        publicKeyUrl: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with Apple Sign In."]
    #[doc = ""]
    #[doc = " @param token The ID token received from Apple to validate."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    #[doc = " @param vars Extra information that will be bundled in the session token."]
    pub fn NClient_authenticateApple(
        client: NClient,
        token: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with a custom id."]
    #[doc = ""]
    #[doc = " @param id A custom identifier usually obtained from an external authentication service."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    pub fn NClient_authenticateCustom(
        client: NClient,
        id: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Authenticate a user with a Steam auth token."]
    #[doc = ""]
    #[doc = " @param token An authentication token from the Steam network."]
    #[doc = " @param username A username used to create the user."]
    #[doc = " @param create True if the user should be created when authenticated."]
    pub fn NClient_authenticateSteam(
        client: NClient,
        token: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        create: bool_,
        vars: NStringMap,
        reqData: NClientReqData,
        successCallback: NSessionCallback,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a Facebook profile to a user account."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param accessToken An OAuth access token from the Facebook SDK."]
    #[doc = " @param importFriends True if the Facebook friends should be imported."]
    pub fn NClient_linkFacebook(
        client: NClient,
        session: NSession,
        accessToken: *const ::std::os::raw::c_char,
        importFriends: bool_,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link an email with password to the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param email The email address of the user."]
    #[doc = " @param password The password for the user."]
    pub fn NClient_linkEmail(
        client: NClient,
        session: NSession,
        email: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a device id to the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param id A device identifier usually obtained from a platform API."]
    pub fn NClient_linkDevice(
        client: NClient,
        session: NSession,
        id: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a Google profile to a user account."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param accessToken An OAuth access token from the Google SDK."]
    pub fn NClient_linkGoogle(
        client: NClient,
        session: NSession,
        accessToken: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a Game Center profile to a user account."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param playerId The player id of the user in Game Center."]
    #[doc = " @param bundleId The bundle id of the Game Center application."]
    #[doc = " @param timestampSeconds The date and time that the signature was created."]
    #[doc = " @param salt A random <c>NSString</c> used to compute the hash and keep it randomized."]
    #[doc = " @param signature The verification signature data generated."]
    #[doc = " @param publicKeyUrl The URL for the public encryption key."]
    pub fn NClient_linkGameCenter(
        client: NClient,
        session: NSession,
        playerId: *const ::std::os::raw::c_char,
        bundleId: *const ::std::os::raw::c_char,
        timestampSeconds: NTimestamp,
        salt: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_char,
        publicKeyUrl: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link an Apple ID to the social profiles on the current user's account."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param token The ID token received from Apple."]
    pub fn NClient_linkApple(
        client: NClient,
        session: NSession,
        token: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a Steam profile to a user account."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param token An authentication token from the Steam network."]
    pub fn NClient_linkSteam(
        client: NClient,
        session: NSession,
        token: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Link a custom id to the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param id A custom identifier usually obtained from an external authentication service."]
    pub fn NClient_linkCustom(
        client: NClient,
        session: NSession,
        id: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a Facebook profile from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param accessToken An OAuth access token from the Facebook SDK."]
    pub fn NClient_unlinkFacebook(
        client: NClient,
        session: NSession,
        accessToken: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink an email with password from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param email The email address of the user."]
    #[doc = " @param password The password for the user."]
    pub fn NClient_unlinkEmail(
        client: NClient,
        session: NSession,
        email: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a Google profile from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param accessToken An OAuth access token from the Google SDK."]
    pub fn NClient_unlinkGoogle(
        client: NClient,
        session: NSession,
        accessToken: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a Game Center profile from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param playerId The player id of the user in Game Center."]
    #[doc = " @param bundleId The bundle id of the Game Center application."]
    #[doc = " @param timestampSeconds The date and time that the signature was created."]
    #[doc = " @param salt A random <c>NSString</c> used to compute the hash and keep it randomized."]
    #[doc = " @param signature The verification signature data generated."]
    #[doc = " @param publicKeyUrl The URL for the public encryption key."]
    pub fn NClient_unlinkGameCenter(
        client: NClient,
        session: NSession,
        playerId: *const ::std::os::raw::c_char,
        bundleId: *const ::std::os::raw::c_char,
        timestampSeconds: NTimestamp,
        salt: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_char,
        publicKeyUrl: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink an Apple profile from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param token An Apple authentication token."]
    pub fn NClient_unlinkApple(
        client: NClient,
        session: NSession,
        token: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a Steam profile from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param token An authentication token from the Steam network."]
    pub fn NClient_unlinkSteam(
        client: NClient,
        session: NSession,
        token: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a device id from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param id A device identifier usually obtained from a platform API."]
    pub fn NClient_unlinkDevice(
        client: NClient,
        session: NSession,
        id: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Unlink a custom id from the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param id A custom identifier usually obtained from an external authentication service."]
    pub fn NClient_unlinkCustom(
        client: NClient,
        session: NSession,
        id: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Import Facebook friends and add them to the user's account."]
    #[doc = ""]
    #[doc = " The server will import friends when the user authenticates with Facebook. This function can be used to be"]
    #[doc = " explicit with the import operation."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param token An OAuth access token from the Facebook SDK."]
    #[doc = " @param reset True if the Facebook friend import for the user should be reset."]
    pub fn NClient_importFacebookFriends(
        client: NClient,
        session: NSession,
        token: *const ::std::os::raw::c_char,
        reset: bool_,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Fetch the user account owned by the session."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    pub fn NClient_getAccount(
        client: NClient,
        session: NSession,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNAccount),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Update the current user's account on the server."]
    #[doc = ""]
    #[doc = " @param session The session for the user."]
    #[doc = " @param username The new username for the user."]
    #[doc = " @param displayName A new display name for the user."]
    #[doc = " @param avatarUrl A new avatar url for the user."]
    #[doc = " @param langTag A new language tag in BCP-47 format for the user."]
    #[doc = " @param location A new location for the user."]
    #[doc = " @param timezone New timezone information for the user."]
    pub fn NClient_updateAccount(
        client: NClient,
        session: NSession,
        username: *const ::std::os::raw::c_char,
        displayName: *const ::std::os::raw::c_char,
        avatarUrl: *const ::std::os::raw::c_char,
        langTag: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        timezone: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Fetch one or more users by id, usernames, and Facebook ids."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param ids List of user IDs. This is list of strings, delimiter is \\0, end of list is \\0\\0"]
    #[doc = " @param usernames List of usernames. This is list of strings, delimiter is \\0, end of list is \\0\\0"]
    #[doc = " @param facebookIds List of Facebook IDs. This is list of strings, delimiter is \\0, end of list is \\0\\0"]
    pub fn NClient_getUsers(
        client: NClient,
        session: NSession,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        usernames: *mut *const ::std::os::raw::c_char,
        usernamesCount: u16,
        facebookIds: *mut *const ::std::os::raw::c_char,
        facebookIdsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNUsers),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Add one or more friends by id."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param ids The ids of the users to add or invite as friends."]
    #[doc = " @param usernames The usernames of the users to add as friends."]
    pub fn NClient_addFriends(
        client: NClient,
        session: NSession,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        usernames: *mut *const ::std::os::raw::c_char,
        usernamesCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Delete one more or users by id or username from friends."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param ids the user ids to remove as friends."]
    #[doc = " @param usernames The usernames to remove as friends."]
    pub fn NClient_deleteFriends(
        client: NClient,
        session: NSession,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        usernames: *mut *const ::std::os::raw::c_char,
        usernamesCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Block one or more friends by id."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param ids The ids of the users to block."]
    #[doc = " @param usernames The usernames of the users to block."]
    pub fn NClient_blockFriends(
        client: NClient,
        session: NSession,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        usernames: *mut *const ::std::os::raw::c_char,
        usernamesCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List of friends of the current user."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    pub fn NClient_listFriends(
        client: NClient,
        session: NSession,
        limit: *const i32,
        state: *const eFriendState,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNFriendList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Create a group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param name The name for the group."]
    #[doc = " @param description A description for the group."]
    #[doc = " @param avatarUrl An avatar url for the group."]
    #[doc = " @param langTag A language tag in BCP-47 format for the group."]
    #[doc = " @param open True if the group should have open membership."]
    pub fn NClient_createGroup(
        client: NClient,
        session: NSession,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        avatarUrl: *const ::std::os::raw::c_char,
        langTag: *const ::std::os::raw::c_char,
        open: bool_,
        maxCount: *const i32,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNGroup),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Delete a group by id."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The group id to to remove."]
    pub fn NClient_deleteGroup(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Add one or more users to the group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group to add users into."]
    #[doc = " @param ids The ids of the users to add or invite to the group."]
    pub fn NClient_addGroupUsers(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List all users part of the group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group."]
    pub fn NClient_listGroupUsers(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        limit: *const i32,
        state: *const eFriendState,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNGroupUserList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Kick one or more users from the group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group."]
    #[doc = " @param ids The ids of the users to kick."]
    pub fn NClient_kickGroupUsers(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Join a group if it has open membership or request to join it."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group to join."]
    pub fn NClient_joinGroup(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Leave a group by id."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group to leave."]
    pub fn NClient_leaveGroup(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List groups on the server."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param name The name filter to apply to the group list."]
    #[doc = " @param limit The number of groups to list."]
    #[doc = " @param cursor A cursor for the current position in the groups to list."]
    pub fn NClient_listGroups(
        client: NClient,
        session: NSession,
        name: *const ::std::os::raw::c_char,
        limit: *const i32,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNGroupList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List of groups the current user is a member of."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    pub fn NClient_listOwnUserGroups(
        client: NClient,
        session: NSession,
        limit: *const i32,
        state: *const eFriendState,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNUserGroupList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List groups a user is a member of."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param userId The id of the user whose groups to list."]
    pub fn NClient_listUserGroups(
        client: NClient,
        session: NSession,
        userId: *const ::std::os::raw::c_char,
        limit: *const i32,
        state: *const eFriendState,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNUserGroupList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Promote one or more users in the group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group to promote users into."]
    #[doc = " @param ids The ids of the users to promote."]
    pub fn NClient_promoteGroupUsers(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Demote a set of users in a group to the next role down."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The group ID to demote in."]
    #[doc = " @param ids The ids of the users to demote."]
    pub fn NClient_demoteGroupUsers(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        ids: *mut *const ::std::os::raw::c_char,
        idsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Update a group."]
    #[doc = ""]
    #[doc = " The user must have the correct access permissions for the group."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param groupId The id of the group to update."]
    #[doc = " @param name A new name for the group."]
    #[doc = " @param description A new description for the group."]
    #[doc = " @param avatarUrl A new avatar url for the group."]
    #[doc = " @param langTag A new language tag in BCP-47 format for the group."]
    #[doc = " @param open True if the group should have open membership."]
    pub fn NClient_updateGroup(
        client: NClient,
        session: NSession,
        groupId: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        avatarUrl: *const ::std::os::raw::c_char,
        langTag: *const ::std::os::raw::c_char,
        open: *const bool_,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List records from a leaderboard."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param leaderboardId The id of the leaderboard to list."]
    #[doc = " @param ownerIds Record owners to fetch with the list of records."]
    #[doc = " @param limit The number of records to list."]
    #[doc = " @param cursor A cursor for the current position in the leaderboard records to list."]
    pub fn NClient_listLeaderboardRecords(
        client: NClient,
        session: NSession,
        leaderboardId: *const ::std::os::raw::c_char,
        ownerIds: *mut *const ::std::os::raw::c_char,
        ownerIdsCount: u16,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNLeaderboardRecordList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List leaderboard records from a given leaderboard around the owner."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param leaderboardId The id of the leaderboard to list."]
    #[doc = " @param ownerId The owner to retrieve records around."]
    #[doc = " @param limit Max number of records to return. Between 1 and 100."]
    pub fn NClient_listLeaderboardRecordsAroundOwner(
        client: NClient,
        session: NSession,
        leaderboardId: *const ::std::os::raw::c_char,
        ownerId: *const ::std::os::raw::c_char,
        limit: i32,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNLeaderboardRecordList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Write a record to a leaderboard."]
    #[doc = ""]
    #[doc = " @param session The session for the user."]
    #[doc = " @param leaderboardId The id of the leaderboard to write."]
    #[doc = " @param score The score for the leaderboard record."]
    #[doc = " @param subscore The subscore for the leaderboard record."]
    #[doc = " @param metadata The metadata for the leaderboard record."]
    pub fn NClient_writeLeaderboardRecord(
        client: NClient,
        session: NSession,
        leaderboardId: *const ::std::os::raw::c_char,
        score: i64,
        subscore: *const i64,
        metadata: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNLeaderboardRecord,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " A request to submit a score to a tournament."]
    #[doc = ""]
    #[doc = " @param session The session for the user."]
    #[doc = " @param tournamentId The tournament ID to write the record for."]
    #[doc = " @param score The score value to submit."]
    #[doc = " @param subscore  An optional secondary value."]
    #[doc = " @param metadata A JSON object of additional properties."]
    pub fn NClient_writeTournamentRecord(
        client: NClient,
        session: NSession,
        tournamentId: *const ::std::os::raw::c_char,
        score: i64,
        subscore: *const i64,
        metadata: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNLeaderboardRecord,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Delete a leaderboard record."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param leaderboardId The id of the leaderboard with the record to be deleted."]
    pub fn NClient_deleteLeaderboardRecord(
        client: NClient,
        session: NSession,
        leaderboardId: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Fetch a list of matches active on the server."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param min_size The minimum number of match participants."]
    #[doc = " @param max_size The maximum number of match participants."]
    #[doc = " @param limit The number of matches to list."]
    #[doc = " @param label The label to filter the match list on."]
    #[doc = " @param authoritative <c>true</c> to include authoritative matches."]
    pub fn NClient_listMatches(
        client: NClient,
        session: NSession,
        min_size: i32,
        max_size: i32,
        limit: i32,
        label: *const ::std::os::raw::c_char,
        authoritative: bool_,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNMatchList),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List notifications for the user with an optional cursor."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param limit The number of notifications to list."]
    #[doc = " @param cacheableCursor A cursor for the current position in notifications to list."]
    pub fn NClient_listNotifications(
        client: NClient,
        session: NSession,
        limit: i32,
        cacheableCursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNNotificationList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Delete one or more notifications by id."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param notificationIds The notification ids to remove."]
    pub fn NClient_deleteNotifications(
        client: NClient,
        session: NSession,
        notificationIds: *mut *const ::std::os::raw::c_char,
        notificationIdsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List messages from a chat channel."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param channelId A channel identifier."]
    #[doc = " @param limit The number of chat messages to list."]
    #[doc = " @param cursor A cursor for the current position in the messages history to list."]
    #[doc = " @param forward Fetch messages forward from the current cursor (or the start)."]
    pub fn NClient_listChannelMessages(
        client: NClient,
        session: NSession,
        channelId: *const ::std::os::raw::c_char,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        forward: bool_,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNChannelMessageList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List active/upcoming tournaments based on given filters."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param categoryStart The start of the categories to include. Defaults to 0."]
    #[doc = " @param categoryEnd The end of the categories to include. Defaults to 128."]
    #[doc = " @param startTime The start time for tournaments. Defaults to current Unix time."]
    #[doc = " @param endTime The end time for tournaments. Defaults to +1 year from current Unix time."]
    #[doc = " @param limit Max number of records to return. Between 1 and 100."]
    #[doc = " @param cursor A next page cursor for listings."]
    pub fn NClient_listTournaments(
        client: NClient,
        session: NSession,
        categoryStart: *const u32,
        categoryEnd: *const u32,
        startTime: *const u32,
        endTime: *const u32,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNTournamentList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List tournament records from a given tournament."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param tournamentId The ID of the tournament to list for."]
    #[doc = " @param limit Max number of records to return. Between 1 and 100."]
    #[doc = " @param cursor A next or previous page cursor."]
    #[doc = " @param ownerIds One or more owners to retrieve records for."]
    pub fn NClient_listTournamentRecords(
        client: NClient,
        session: NSession,
        tournamentId: *const ::std::os::raw::c_char,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        ownerIds: *mut *const ::std::os::raw::c_char,
        ownerIdsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNTournamentRecordList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List tournament records from a given tournament around the owner."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param tournamentId The ID of the tournament to list for."]
    #[doc = " @param ownerId The owner to retrieve records around."]
    #[doc = " @param limit Max number of records to return. Between 1 and 100."]
    pub fn NClient_listTournamentRecordsAroundOwner(
        client: NClient,
        session: NSession,
        tournamentId: *const ::std::os::raw::c_char,
        ownerId: *const ::std::os::raw::c_char,
        limit: i32,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNTournamentRecordList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Join a tournament if it has open membership or request to join it."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param tournamentId The id of the tournament to join."]
    pub fn NClient_joinTournament(
        client: NClient,
        session: NSession,
        tournamentId: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List storage objects in a collection which have public read access."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param collection The collection to list over."]
    #[doc = " @param limit The number of objects to list."]
    #[doc = " @param cursor A cursor to paginate over the collection."]
    pub fn NClient_listStorageObjects(
        client: NClient,
        session: NSession,
        collection: *const ::std::os::raw::c_char,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNStorageObjectList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " List storage objects in a collection which belong to a specific user and have public read access."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param collection The collection to list over."]
    #[doc = " @param userId The user ID of the user to list objects for."]
    #[doc = " @param limit The number of objects to list."]
    #[doc = " @param cursor A cursor to paginate over the collection."]
    pub fn NClient_listUsersStorageObjects(
        client: NClient,
        session: NSession,
        collection: *const ::std::os::raw::c_char,
        userId: *const ::std::os::raw::c_char,
        limit: i32,
        cursor: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                arg3: *const sNStorageObjectList,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Write objects to the storage engine."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param objects The objects to write."]
    pub fn NClient_writeStorageObjects(
        client: NClient,
        session: NSession,
        objects: *const sNStorageObjectWrite,
        objectsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                acks: *const sNStorageObjectAck,
                count: u16,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Read one or more objects from the storage engine."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param objectIds The objects to read."]
    pub fn NClient_readStorageObjects(
        client: NClient,
        session: NSession,
        objectIds: *const sNReadStorageObjectId,
        objectIdsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: NClient,
                arg2: NClientReqData,
                objects: *const sNStorageObject,
                count: u16,
            ),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Delete one or more storage objects."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param objectIds The ids of the objects to delete."]
    pub fn NClient_deleteStorageObjects(
        client: NClient,
        session: NSession,
        objectIds: *const sNDeleteStorageObjectId,
        objectIdsCount: u16,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Execute a Lua function with an input payload on the server."]
    #[doc = ""]
    #[doc = " @param session The session of the user."]
    #[doc = " @param id The id of the function to execute on the server."]
    #[doc = " @param payload The payload to send with the function call."]
    pub fn NClient_rpc(
        client: NClient,
        session: NSession,
        id: *const ::std::os::raw::c_char,
        payload: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNRpc),
        >,
        errorCallback: NClientErrorCallback,
    );
}
extern "C" {
    #[doc = " Execute a Lua function with an input payload on the server."]
    #[doc = ""]
    #[doc = " @param http_key The server's runtime HTTP key."]
    #[doc = " @param id The id of the function to execute on the server."]
    #[doc = " @param payload The payload to send with the function call."]
    pub fn NClient_rpc_with_http_key(
        client: NClient,
        http_key: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
        payload: *const ::std::os::raw::c_char,
        reqData: NClientReqData,
        successCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: NClient, arg2: NClientReqData, arg3: *const sNRpc),
        >,
        errorCallback: NClientErrorCallback,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NClientParameters {
    #[doc = " The key used to authenticate with the server without a session. Defaults to \"defaultkey\"."]
    pub serverKey: *const ::std::os::raw::c_char,
    #[doc = " The host address of the server. Defaults to \"127.0.0.1\"."]
    pub host: *const ::std::os::raw::c_char,
    #[doc = " The port number of the server."]
    #[doc = " set NDEFAULT_PORT to use default server ports (can be changed in the server config):"]
    #[doc = " 7349 - gRPC API"]
    #[doc = " 7350 - HTTP API"]
    #[doc = " 443  - gRPC & HTTP API if SSL is enabled"]
    pub port: i32,
    #[doc = " Set connection strings to use the secure mode with the server. Defaults to false."]
    #[doc = " The server must be configured to make use of this option. With HTTP, GRPC, and WebSockets the server must"]
    #[doc = " be configured with an SSL certificate or use a load balancer which performs SSL termination."]
    #[doc = " For rUDP you must configure the server to expose it's IP address so it can be bundled within session tokens."]
    #[doc = " See the server documentation for more information."]
    pub ssl: bool_,
}
#[test]
fn bindgen_test_layout_NClientParameters() {
    assert_eq!(
        ::std::mem::size_of::<NClientParameters>(),
        24usize,
        concat!("Size of: ", stringify!(NClientParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<NClientParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(NClientParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NClientParameters>())).serverKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NClientParameters),
            "::",
            stringify!(serverKey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NClientParameters>())).host as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NClientParameters),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NClientParameters>())).port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NClientParameters),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NClientParameters>())).ssl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NClientParameters),
            "::",
            stringify!(ssl)
        )
    );
}
pub type tNClientParameters = NClientParameters;
extern "C" {
    #[doc = " Creates a default client to interact with Nakama server."]
    #[doc = ""]
    #[doc = " @param parameters the client parameters"]
    pub fn createDefaultNakamaClient(parameters: *const tNClientParameters) -> NClient;
}
extern "C" {
    #[doc = " Creates the gRPC client to interact with Nakama server."]
    #[doc = ""]
    #[doc = " @param parameters the client parameters"]
    pub fn createGrpcNakamaClient(parameters: *const tNClientParameters) -> NClient;
}
extern "C" {
    #[doc = " Creates the REST client (HTTP/1.1) to interact with Nakama server."]
    #[doc = ""]
    #[doc = " @param parameters the client parameters"]
    pub fn createRestNakamaClient(parameters: *const tNClientParameters) -> NClient;
}
extern "C" {
    #[doc = " Destroys a client."]
    #[doc = ""]
    #[doc = " @param client the client"]
    pub fn destroyNakamaClient(client: NClient);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub const NLogLevel__NLogLevel_Debug: NLogLevel_ = 1;
pub const NLogLevel__NLogLevel_Info: NLogLevel_ = 2;
pub const NLogLevel__NLogLevel_Warn: NLogLevel_ = 3;
pub const NLogLevel__NLogLevel_Error: NLogLevel_ = 4;
pub const NLogLevel__NLogLevel_Fatal: NLogLevel_ = 5;
#[doc = " Logger"]
pub type NLogLevel_ = ::std::os::raw::c_uint;
#[doc = " Logger"]
pub use self::NLogLevel_ as eNLogLevel;
pub type NLogSink = ::std::option::Option<
    unsafe extern "C" fn(
        level: eNLogLevel,
        message: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Initialize logger with <c>NConsoleLogSink</c>"]
    #[doc = ""]
    #[doc = " @param level logging boundary"]
    pub fn NLogger_initWithConsoleSink(level: eNLogLevel);
}
extern "C" {
    #[doc = " Initialize logger with custom log sink"]
    #[doc = ""]
    #[doc = " @param sink custom log sink"]
    #[doc = " @param level logging boundary"]
    pub fn NLogger_init(sink: NLogSink, level: eNLogLevel);
}
extern "C" {
    pub fn NLogger_setSink(sink: NLogSink);
}
extern "C" {
    pub fn NLogger_setLevel(level: eNLogLevel);
}
extern "C" {
    pub fn NLogger_log(
        level: eNLogLevel,
        message: *const ::std::os::raw::c_char,
        module_name: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NLogger_vformat(
        level: eNLogLevel,
        module_name: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn getNakamaSdkVersion() -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
